/* --------------------------------------------------------------
    Целые числа с неограниченной разрядной сеткой (версия 2.2).
    Базовые функции в машинно-независимом варианте.

    http://www.imach.uran.ru/cbignum

    Copyright 1999-2025, Р.Н.Шакиров, ИМаш УрО PAH.
    All Rights Reserved.

    Код предоставляется на условиях лицензии "public domain",
    т.е. допускается свободное применение, модификация и
    распространение кода при условии сохранения копирайта
    и добавления сведений о всех внесенных изменениях.

    ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ"
    БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ. ВЫ
    ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ И РИСК. АВТОР
    НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ, УЩЕРБ,
    УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
    ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.
-------------------------------------------------------------- */
#ifndef _CBIGNUMF_INL
#define _CBIGNUMF_INL

#ifndef _CBIGNUMF_H
#include "Cbignumf.h"
#endif//_CBIGNUMF_H

#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#define DISALLOW_EXARRAY_SHORTTYPE
#include "Cbignum.h"
#define BITS    (CHAR_BIT * sizeof (CBNL))
#define LBITS   (CHAR_BIT * sizeof (long))

#ifndef NDEBUG
cTTY cPrg (cBigNumberProgress);
#define CPRG(a) cPrg<<a
#else //NDEBUG
#define CPRG(a)
#endif//NDEBUG

#ifdef  _MSC_VER
#pragma auto_inline (off)
#endif/*_MSC_VER*/

static int count_floor2nBITS()
{
  int n = 2; while (n <= (BITS-1)/2) n <<= 1;
  return (n);
}
static int floor2nBITS = count_floor2nBITS();
static int floor2nBITSm1 = floor2nBITS - 1;

//================================================
//      Реализация операций над числами CBNL.
//================================================

#ifdef  __cplusplus
extern "C" {
#endif//__cplusplus

//      В числе со знаком значащими считаются самый старший бит,
//      отличный от знакового бита и все младшие по отношению к нему
//      биты. Например, у 0 и -1 нет значащих битов, 1 и -2 имеют
//      1 значащий бит, числа 127 и -128 имеют 7 значащих бит.
//      Модуль числа с n значащими битами не превосходит 2 в
//      степени n.

int    _CBNL_C  cLongBits (CBNL num)            // Число значащих бит
{                                               // в диапазоне 0..BITS-1.
  num ^= (num >> (BITS-1));                     // Отрицательное число.
#ifdef  _ubsrCBNL
  unsigned long n;
  return (_ubsrCBNL (&n, num)? (int)n + 1: 0);
#else //_ubsrCBNL
  int n = 0;
  int k = floor2nBITSm1;                        // Сдвиг ..31,15,7,3,1.
  do
  {
    int k0 = (((num >> k) == 0) - 1) & (k + 1); num >>= k0; n += k0;
  }
  while ((k >>= 1) != 0);
  return (n += (num > 0));                      // Сдвиг 0.
#endif//_ubsrCBNL
}

//      В числе без знака значащими считается самый старший бит,
//      отличный от 0 и все младшие по отношению к нему биты.

int    _CBNL_C  cULongBits (unsigned CBNL num)  // Число значащих бит
{                                               // в диапазоне 0..BITS.
#ifdef  _ubsrCBNL
  unsigned long n;
  return (_ubsrCBNL (&n, num)? (int)n + 1: 0);
#else //_ubsrCBNL
  int n = (((CBNL)num >= 0) - 1); num &= ~n;
      n &= BITS;                                // BITS значащих битов.
  int k = floor2nBITSm1;                        // Сдвиг ..31,15,7,3,1.
  do
  {
    int k0 = (((num >> k) == 0) - 1) & (k + 1); num >>= k0; n += k0;
  }
  while ((k >>= 1) != 0);
  return (n += (num > 0));                      // Сдвиг 0.
#endif//_ubsrCBNL
}

//      К младшим 0-битам относятся все значащие биты,
//      младшие по отношению к младшему ненулевому биту.
//      Например, у 0 и нечетных чисел нет младших 0-битов,
//      2 и -2 имеют 1 младший бит, 128 и -128 имеют
//      7 младших 0-битов. Модуль числа с n младшими
//      0-битами не меньше 2 в степени n.

int    _CBNL_C  cLongExBits (CBNL num)          // Число младших 0-битов
{                                               // в диапазоне 0..BITS-1.
#ifdef  _ubsfCBNL
  unsigned long n;
  return (_ubsfCBNL (&n, num)? (int)n: 0);
#else //_ubsfCBNL
  int n = 0;
  if (num) while ((num & (CBNL)1) == 0) { ++n; num >>= 1; }
  return (n);
#endif //_ubsfCBNL
}

//      Проверка числа на положительность и равенство 2 в степени n.

int    _CBNL_C  cLongExactLog2 (CBNL num)       // Точный log2 или -1.
{                                               // log2 в диапазоне 0..BITS-1.
  int n = cLongExBits (num);
  if ((num >> n) != 1) n = -1;
  return n;
}

//      Случайное CBNL значение с равномерным распределением.

#ifdef CBNL_LONG_LONG                           // Inline если CBNL long.
unsigned CBNL _CBNL_C cLongRandom (             // Случайное число.
                unsigned long (*pfnRand)()      // Генератор случайных слов.
)                                               // Выдает случайное число.
{
  unsigned CBNL lRand = (*pfnRand)();
  int sh = LBITS;
  do lRand |= ((CBNL)(*pfnRand)() << sh);
  while ((sh += LBITS) < BITS);
  return (lRand);
}
#endif//CBNL_LONG_LONG

#ifdef  __cplusplus
}
#endif//__cplusplus

//================================================
//      Реализация операций над числами cBigNumber.
//================================================
//      Неограниченное целое число хранится в массиве типа CBNL.
//      Элемент массива с нулевым индексом содержит число CBNL-слов,
//      требуемых для представления неограниченного числа в
//      дополнительном двоичном коде, в последующих элементах
//      содержится код числа в порядке от младших разрядов к
//      старшим. Знак числа находится в последнем слове.
//
//      Операции реализованы в виде функций языка C.
//      Ряд функции по соображениям оптимизации не заполняют
//      поле числа слов в результирующем числе; вместо этого
//      число слов выдается в качестве значения типа size_t.
//      Имена таких функций начинаются со знака подчеркивания;
//      они сопровождаются inline-функцией, вызывающей функцию
//      и заполняющей поле числа слов.
//
//      Неограниченные числа передаются через макро EXPTR(CBNL)
//      или CBPTR(CBNL), если применяется модификатор const.
//      Макро заменяется на CBNL* в рабочем режиме и exptr<CBNL>
//      в отладочном режиме с проверкой выхода индекса за границы
//      массива.
//
//      Динамический контроль входных данных
//      управляется следующими макросами:
//      NDEBUG    - отключает контроль выхода указателя
//                  за границы массива и контроль ошибок
//                  во входных параметрах функций.
//      NCHECKPTR - отключает контроль выхода указателя
//                  за границы массива; также можно
//                  отключить контроль только для входных
//                  массивов с помощью _CBIGNUM_NCHECKPTR.
//
//      Внешние ссылки объявлены, как "C", чтобы
//      заблокировать преобразование имен.
//      Это позволяет переносить объектные модули
//      между различными версиями трансляторов.
//      Исключением является отладочный режим с
//      контролем индексов, в котором ассемблерные
//      объектные модули из дополнительного пакета
//      вызываются через переходники, преобразующие
//      EXPTR(CBNL) и CBPTR(CBNL) в CBNL*.

#ifdef  NCHECKPTR
#ifdef  __cplusplus
extern "C" {
#endif//__cplusplus
#endif//NCHECKPTR

//================================================
//      Диагностические функции.
//================================================

//      Вывод внутреннего представления выполняется в порядке
//      от старших слов к младшим. Каждое слово предваряется
//      пробелом и выводится в шестнадцатеричном представлении,
//      в порядке от старших разрядов к младшим.
//      Вывод числа завершается переводом строки.

void    cBigNumberDump (                        // Вывод кода в сообщения.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  for (; n1; n1--) cBigNumberMessages <<" "<< (const char*) cHexDump (p1 [n1]);
  cBigNumberMessages << "\n";
}

//      Короткий дамп содержит старшее слово в шестнадцатеричном
//      представлении и число и число байт.
//      the high word followed by total number of words.

void    cBigNumberInfo (                        // Информация (короткий дамп).
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  cBigNumberMessages << cHexDump (p1 [n1]);
  if (n1 > 1)
    cBigNumberMessages << "... (" << (CBNL)(n1 * sizeof (CBNL)) << " bytes)\n";
}

void    cBigNumberERange  (                     // Сообщение об ошибке.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )
{
  cBigNumberMessages << "cBigNumber value out of range: ";
  cBigNumberInfo (p1);
  abort();
}

//================================================
//      Информационные функции.
//================================================

//      Значащими считаются самое старшие слово, содержащее не
//      только знаковый бит и биты его расширения и все младшие
//      по отношению к нему слова.

size_t  cBigNumberWords (                       // Число значащих слов.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Возможно, ненормализованное.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1)
  {
    CBNL sign = p1 [n1] >> (BITS-1);            // Знак 0 или -1.
    do
    {
      if (p1 [n1] != sign) break;               // Есть значащие биты?
    }
    while (--n1 != 0);
  }
  return (n1);
}

//      Подсчет значащих битов в неограниченном числе.
//      Если их число > CBNL_MAX вызывается cBigNumberERange().

CBNL    cBigNumberBits (                        // Число значащих бит.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Возможно, ненормализованное.

{
  size_t n = cBigNumberWords(p1);               // Число значащих слов.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n)
  {                                             // Проверка переполнения.
    if ((CBNL)n > (CBNL)(CBNL_MAX / BITS))
       cBigNumberERange (p1);
    return ((CBNL)(n - 1) * BITS + cULongBits ((unsigned CBNL)
                                    (p1 [n] ^ (p1 [n1] >> (BITS-1)))));
  }
  return (0);
}

//      К младшим 0-словам относятся все значащие слова,
//      младшие по отношению к младшему ненулевому слову.
//      Если все слова нулевые, то младших 0-слов нет.

size_t  cBigNumberExWords (                     // Число младших 0-слов.
                const   CBPTR(CBNL) p1          // Неограниченное число.
)                                               // Возможно, ненормализованное.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  for (size_t n = 0; n < n1; n++)
  {
    if (p1 [n + 1] != 0) return (n);            // Число 0-слов.
  }
  return (0);
}

//      Подсчет младших 0-битов в неограниченном числе.
//      Если их число больше > CBNL_MAX вызывается cBigNumberERange().

CBNL    cBigNumberExBits (                      // Число младших 0-битов.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Возможно, ненормализованное.

{
  size_t n = cBigNumberExWords(p1);             // Число младших 0-слов.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1)
  {                                             // Проверка переполнения.
    if ((CBNL)n > (CBNL)((CBNL_MAX - (BITS - 1)) / BITS))
      cBigNumberERange (p1);
    return ((CBNL)n * BITS + cLongExBits (p1 [n + 1]));
  }
  return (0);
}

//================================================
//      Нормализация и денормализация.
//================================================

//      Число считается нормализованным, если для записи дополнительного
//      кода используется минимально возможное число CBNL-слов, но не
//      менее одного слова:
//      - если число слов больше 1, то старшее слово отличается от
//        результата расширения старшего бита предпоследнего слова;
//      - нуль представляется одним нулевым словом.

size_t _CBNL_C  cBigNumberIsFit (               // Проверка нормализованности.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Если число нормализованное,
{                                               // то выдает 1 иначе 0.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.

  if (n1 > 1) return ((p1 [n1] != (p1 [n1 - 1] >> (BITS-1))));

  return (n1);                                  // Число слов 1 или 0.
}

//      Нормализация к минимальному числу слов,
//      потребному для хранения числа (не менее 1).

size_t _CBNL_C _cBigNumberFit (                 // Нормализация.
                        EXPTR(CBNL) p1          // Буфер с числом.
        )                                       // Размер буфера >= 2.
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  p1 += n1;                                     // Подготовка указателя.

  if (n1)                                       // Если в старшем слове и в
  {                                             // старшем бите предыдущего
    CBNL pass, lp = *p1--;                      // слова все 0 или все 1, то
    do continue;                                // удаляется старшее слово.
    while (--n1 != 0 &&
        (pass = lp, lp = *p1--, pass == (lp >> (BITS-1))));
  }                                             // Если ни одного слова нет,
  else { p1 [1] = 0; }                          // добавляется нулевое слово.

  return (n1 + 1);                              // Число слов.
}
//#define cBigNumberFit(p1)     (size_t)(*(p1)=_cBigNumberFit(p1))

//      Денормализация с увеличением числа слов до заданной
//      величины. Если заданная величина не больше исходного
//      числа слов, то число слов увеличивается на 1.
//
//      Функция выдает НЕ нормализованный результат.

size_t _CBNL_C _cBigNumberFitTo (               // Денормализация.
                        EXPTR(CBNL) p1,         // Буфер с числом.
                        size_t      n           // Число слов.
        )                                       // Размер буфера не менее
{                                               // max (*p1 + 2, n + 1).
  size_t n1 = (size_t)(*p1);                    // Число слов.
  CBNL pass = p1 [n1] >> (BITS-1);              // Перенос.

  do
    p1 [++n1] = pass;                           // Распространяем перенос.
  while (n1 < n);

  return (n1);                                  // Число слов.
}
//#define cBigNumberFitTo(p1,n) (size_t)(*(p1)=_cBigNumberFitTo(p1,n))

//================================================
//      Функции сравнения.
//================================================

//      Длина чисел уравнивается путем расширения
//      знакового разряда более короткого числа.
//      Полученные слова сравниваются пословно в порядке
//      от старших слов к младшим до первого несовпадения.
//      Сравнение старших слова - знаковое, сравнение
//      остальных слов - беззнаковое.
//
//      Функция не требует нормализации операндов.
//      Для целей оптимизации вместо фактического расширения
//      знакового разряда применяется алгоритмический эквивалент.

int    _CBNL_C  cBigNumberComp (                // Сравнение p1, p2.
                const   CBPTR(CBNL) p1,         // Число.
                const   CBPTR(CBNL) p2          // Число.
        )                                       // Выдает -1 при p1 <  p2
                                                // Выдает  0 при p1 == p2
                                                // Выдает  1 при p1  > p2
{                                               // p1, p2 могут совпадать.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов в p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов в p2.
  CBNL lp1 = CBPTRBASE(p1)[n1];                 // Знаковое слово p1.
  CBNL lp2 = CBPTRBASE(p2)[n2];                 // Знаковое слово p2.

//      Сравнение знаковых слов.

  if (n1 == n2)                                 // Длины p1, p2 совпадают.
  {
    if (lp1 != lp2) goto NotSameSignWord;       // Знаковые слова не совпадают.
    n1 -= (n1 != 0);                            // Сравнение незнаковых слов.
  }
  else if (n1 > n2)                             // Если число p1 длиннее, то
  {                                             // проводится сравнение с
    lp2 >>= (BITS - 1); --n1;                   // расширением знака p2.
    if (lp1 != lp2) goto NotSameSignWord;       // Знаковые слова не совпадают.
    if (n1 > n2)                                // Сравнение незнаковых слов.
    {
      do                                        // Цикл сравнения.
      {
        lp1 = p1 [n1]; --n1;                    // Чтение слова.
        if (lp1 != lp2) goto NotSame;           // Слова не совпадают.
      }
      while (n1 > n2);                          // Конец цикла сравнения.
    }
  }
  else // (n1 < n2)                             // Если число p2 длиннее, то
  {                                             // проводится сравнение с
    lp1 >>= (BITS - 1); --n2;                   // расширением знака p1.
    if (lp1 != lp2) goto NotSameSignWord;       // Знаковые слова не совпадают.
    if (n1 < n2)                                // Сравнение незнаковых слов.
    {
      do                                        // Цикл сравнения.
      {
        lp2 = p2 [n2]; --n2;                    // Чтение слова.
        if (lp1 != lp2) goto NotSame;           // Слова не совпадают.
      }
      while (n1 < n2);                          // Конец цикла сравнения.
    }
  }

//      Попарное сравнение незнаковых слов.

  if (n1)
  {
    do                                          // Цикл сравнения.
    {
      lp1 = p1 [n1]; lp2 = p2 [n1]; --n1;       // Чтение слова.
      if (lp1 != lp2) goto NotSame;             // Слова не совпадают.
    }
    while (n1);                                 // Конец цикла сравнения.
  }

  return (0);                                   // Значения совпадают.
NotSame:                                        // Значения не совпадают.
  return (((unsigned CBNL)lp1 >= (unsigned CBNL)lp2) * 2 - 1);
NotSameSignWord:                                // Не совпадают знаковые слова.
  return ((lp1 >= lp2) * 2 - 1);
}

//      Специальное сравнение для деления.
//      Предполагается, что:
//      - числа нормализованы.
//      - размер первого числа не меньше размера второго числа.
//      - разница размеров передается в третьем параметре.
//      Перед cравнением второе число сдвигается влево до совпадения размеров.
//
//      Размер второго числа определяется относительно первого числа путем
//      вычитания разницы, т.е. слово размера 0 игнорируется и читается
//      только массив дополнительного кода, начиная со слова 1.

int    _CBNL_C _cBigNumberCompHigh (            // Сравнение от старших слов.
                const   CBPTR(CBNL) p1,         // Число.
                const   CBNL*       p2,         // Число.
                        size_t      k2          // Разница размеров.
        )                                       // Выдает
                                                // -1 при p1 <  p2 << k2*BITS
                                                //  0 при p1 == p2 << k2*BITS
                                                //  1 при p1  > p2 << k2*BITS
{                                               // p1, p2 могут совпадать.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов в p1.
  size_t n2 = n1 - k2;                          // Число слов в p2.
  assert (n1 > k2);                             // Проверка размера.

  CBNL lp1 = p1 [n1--];                         // Текущее слово p1.
  CBNL lp2 = p2 [n2--];                         // Текущее слово p2.
  assert (!n1 || lp1 != (p1 [n1] >> (BITS-1))); // Проверка нормализованности.
  assert (!n2 || lp2 != (p2 [n2] >> (BITS-1))); // Проверка нормализованности.

//      Сравнение знаковых слов.

  if (lp1 != lp2) return ((lp1 > lp2) * 2 - 1); // Слова не совпадают.

//      Попарное сравнение незнаковых слов.

  if (n2)
  do                                            // Цикл сравнения.
  {
    lp1 = p1 [n1--]; lp2 = p2 [n2--];           // Чтение слов.
    if (lp1 != lp2)                             // Слова не совпадают.
      return (((unsigned CBNL)lp1 > (unsigned CBNL)lp2) * 2 - 1);
  }
  while (n2);                                   // Конец цикла сравнения.

//      Сравнение по зоне сдвига.

  if (n1)
  do
  {
    if (p1 [n1--] != 0) return 1;               // Несовпадение.
  }
  while (n1);

  return (0);                                   // Значения совпадают.
}

//      Специальное быстрое сравнение числа c 0.
//
//      Алгоритм оптимизирован для исключения условных переходов.
//      Выдается побитовая сумма знакового слова с числом слов,
//      поделенным на 2 (у положительного числа знаковое
//      слово может быть нулевым, но тогда число слов > 1).
//
//      Предполагается что в числе нет лишних старших 0-слов
//      иначе возможен ложноотрицательный результат.

inline
CBNL    cBigNumberNot0  (                       // Сравнение с 0:
                const CBPTR(CBNL) p1_debug      // выдает 0 при p1 == 0
                )                               // иначе отлично от 0.
{
  const CBNL* p1 = CBPTRBASE(p1_debug);         // Обычный указатель.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  return (p1 [n1] | (*p1 >> 1));
}

//================================================
//      Копирования и побитовой инверсии.
//================================================

#ifndef _CBIGNUM_ASM                            // Если не в Cbignumf.cpp

//      Точное копирование.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void   _CBNL_C  cBigNumberCopy (                // Копирование p = p1.
                const   CBPTR(CBNL) p1,         // Копируемое число.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*p++ = *CBPTRBASE(p1++));// Число слов.
  if (n1)
  {
    do                                          // Цикл копирования слов.
      { *p++ = *p1++; }                         // Копирование слова.
    while (--n1 != 0);                          // Конец цикла копирования.
  }
}

#endif//_CBIGNUM_ASM

//      Побитовая инверсия.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void    cBigNumberCompl (                       // Инверсия p = ~p1.
                const   CBPTR(CBNL) p1,         // Инвертируемое число.
                        EXPTR(CBNL) p           // Буфер размера
                                                // max (*p1 + 1, 2).
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*p++ = *CBPTRBASE(p1++));// Число слов.
  if (n1)
  {
    do                                          // Цикл инверсии слов.
      { *p++ = ~*p1++; }                        // Инверсия слова.
    while (--n1 != 0);                          // Конец цикла инверсии.
  }
  else
  {
    p [-1] = 1; p [0] = ~(CBNL)0;               // Число ~0.
  }
}

//================================================
//      Функции сдвига на заданное число слов.
//================================================

//      Сдвиг влево сопровождается увеличением числа слов,
//      если только сдвигаемое слово не равно 0.
//      Сдвиг эквивалентен умножению на 2 в степени (BITS * k1).
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void    cBigNumberCopyShl (                     // Сдвиг p = p1 << (BITS*k1).
                const   CBPTR(CBNL) p1,         // Сдвигаемое число.
                        size_t      k1,         // Показатель сдвига в словах.
                        EXPTR(CBNL) p           // Буфер размера
                                                // max (*p1 + k1, 1) + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1 <= 1 && p1 [n1] == 0) k1 = 0;          // Нулевое число.
  p1 += n1; *p = (CBNL)(n1 + k1); p += (n1 + k1);
  if (n1)
  do                                            // Цикл копирования слов.
    { *p-- = *p1--; }                           // Копирование слова.
  while (--n1 != 0);                            // Конец цикла копирования.
  if (k1)
  do                                            // Цикл обнуления слов.
    { *p-- = 0; }                               // Обнуление слова.
  while (--k1 != 0);                            // Конец цикла обнуления.
}

//      Сдвиг вправо выполняется с сохранением знака числа.
//      Сдвиг эквивалентен делению на 2 в степени (BITS * k1).
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void    cBigNumberCopyShr (                     // Сдвиг p = p1 >> (BITS*k1).
                const   CBPTR(CBNL) p1,         // Сдвигаемое число.
                        size_t      k1,         // Показатель сдвига в словах.
                        EXPTR(CBNL) p           // Буфер размера
                                                // max (*p1 - k1, 1) + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1 > k1)
  {
    *p++ = (CBNL)(n1 -= k1);                    // Число слов.
    p1 += (k1 + 1);                             // Сдвиг.
    do                                          // Цикл копирования слов.
      { *p++ = *p1++; }                         // Копирование слова.
    while (--n1 != 0);                          // Конец цикла копирования.
  }
  else
  {
    *p = 1; p [1] = p1 [n1] >> (BITS-1);        // Число 0 или -1.
  }
}

#ifndef _CBIGNUM_ASM                            // Если не в Cbignumf.cpp

//      Специализированный правый сдвиг с денормализацией,
//      комбинирующий cBigNumberCopyShr() and cBigNumberFitTo().
//
//      Сдвиг эквивалентен делению на 2 в степени (BITS * k1).
//      Денормализация увеличивает число слов до k1, если k1
//      больше и добавляет одно дополнительное слово.
//
//      Для целей оптимизации предполагается, что:
//      - Размер числа больше k1.
//
//      Функции выдают НЕ нормализованный результат.

void   _CBNL_C  cBigNumberCopyShrToM (          // Сдвиг с денормализацией
                                                // p = p1 >> (BITS*k1).
                const   CBPTR(CBNL) p1,         // Сдвигаемое число, *p1 > k1.
                        size_t      k1,         // Показатель сдвига в словах.
                        EXPTR(CBNL) p           // Буфер размера
                                                //   max (k1, *p1 - k1) + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  assert (n1 > k1);                             // Проверка размера.
  n1 -= k1;                                     // Число копируемых слов.
  p1 += ++k1;                                   // Сдвиг.

  if (k1 <= n1) k1 = n1 + 1;                    // Число слов в результате.
  *p++ = (CBNL) k1;                             // Число слов в результате.
  k1 -= n1;                                     // Число слов расширения.

  CBNL lp1;
  do
    *p++ = lp1 = *p1++;                         // Копирование слов.
  while (--n1 != 0);

  lp1 >>= (BITS-1);                             // Перенос.
  do
    *p++ = lp1;                                 // Расширение переноса.
  while (--k1 != 0);
}

//      Функция для сдвига беззнакового числа.

void   _CBNL_C  cBigNumberCopyShrUToM (         // Сдвиг с денормализацией
                                                // p = p1 >> (BITS*k1).
                const   CBPTR(CBNL) p1,         // Беззнаковое число, *p1 > k1.
                        size_t      k1,         // Показатель сдвига в словах.
                        EXPTR(CBNL) p           // Буфер размера
                                                //   max (k1, *p1 - k1) + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  assert (n1 > k1);                             // Проверка размера.
  n1 -= k1;                                     // Число копируемых слов.
  p1 += ++k1;                                   // Сдвиг.

  if (k1 <= n1) k1 = n1 + 1;                    // Число слов в результате.
  *p++ = (CBNL) k1;                             // Число слов в результате,
  k1 -= n1;                                     // Число добавляемых 0-слов.

  do
    *p++ = *p1++;                               // Копирование слов.
  while (--n1 != 0);

  do
    *p++ = 0;                                   // Добавление 0-слов.
  while (--k1 != 0);
}

//      Денормализация с очисткой, более быстрая,
//      чем очистка с помощью cBigNumberFitTo().
//
//      Функция выдает НЕ нормализованный результат.

void   _CBNL_C  cBigNumberClearTo (             // Денормализация с обнулением.
                        EXPTR(CBNL) p1,         // Буфер размера n + 1.
                        size_t      n           // Число слов.
        )
{
  *p1++ = (CBNL) n;                             // Число слов.
  if (n)
  do
    *p1++ = 0;                                  // Обнуление.
  while (--n != 0);
}

#endif//_CBIGNUM_ASM

//      Вырезка заданного числа слов из числа с добавлением старшего 0-слова.
//
//      Функция выдает НЕ нормализованный результат.

void    cBigNumberCutOut (                      // Вырезка.
                const   CBPTR(CBNL) p1,         // Копируемое число.
                        size_t      k1,         // Начальная позиция.
                        size_t      n,          // Число слов.
                        EXPTR(CBNL) p           // Буфер размера n1 + 1.
        )                                       // p1, p могут совпадать.
{
  assert ((size_t)(*CBPTRBASE(p1)) >= k1 + n);  // Проверка размера.
  *p++ = (CBNL)(n + 1);                         // Число слов.
  if (n > 0)                                    // Требуется копирование.
  {
    p1 += (k1 + 1);                             // Начало.
    do                                          // Цикл копирования слов.
      { *p++ = *p1++; }                         // Копирование слова.
    while (--n != 0);                           // Конец цикла копирования.
  }
  *p = 0;                                       // Старшее слово.
}

//================================================
//      Унарные операции.
//================================================

//      Смена знака делается путем побитовой инверсии и прибавления 1.
//      1) Меняем знак слов вплоть до первого ненулевого результата.
//      2) Инвертируем последующие слова.
//      3) Если последующих слов нет, а старшее слово равно 100..(побитово),
//         то добавить нулевое слово.
//         Если два старших слова результата равны 11.. и 100..(побитово),
//         то удалить старшее слово.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t _CBNL_C _cBigNumberNeg (                 // Смена знака p = -p1.
                const   CBPTR(CBNL) p1,         // Исходное число.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  p++;
  size_t n = n1;                                // Счетчик слов.
  if (n)
  do                                            // Цикл смены знака.
  {
    CBNL lp;                                    // Оптимизация слова.
    if ((*p = lp = -*p1) != 0)                  // Смена знака.
    {                                           // Получено ненулевое слово.
      if (--n != 0)                             // Есть еще слова?
      {                                         // Если слова есть:
        do                                      // Цикл инверсии.
          { ++p1; ++p; *p = lp = ~*p1; }        // Побитовая инверсия слова.
        while (--n != 0);                       // Конец цикла инверсии.
        return (n1 - (lp == (p [-1] >> (BITS-1))));
      }                                         // Старшее слово лишнее?
                                                // Если больше слов нет, то
      if (lp != CBNL_MIN) return (n1);          // проверка переполнения и
      p [1] = 0; return (n1 + 1);               // добавление старшего слова.
    }
  }
  while ((++p1, ++p, --n) != 0);                // Конец цикла смены знака.

  return (n1);                                  // Все слова нулевые.
}
//#define cBigNumberNeg(p1,p)   (size_t)(*(p)=_cBigNumberNeg(p1,p))

//      Специальная смена знака без изменения длины.
//
//      ПРИМЕЧАНИЕ: функция не добавляет старшее нулевое слово к CBNL_MIN
//                  и поэтому возвращает такое же отрицательное число.
//
//      Функция может вернуть не нормализованный результат.

void    cBigNumberMNegF (                       // Смена знака p1 = -p1.
                        EXPTR(CBNL) p1          // Исходное число и результат.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  if (n1)
  do                                            // Цикл смены знака.
  {
    if ((*p1 = -*p1) != 0)                      // Смена знака.
    {                                           // Получено ненулевое слово.
      if (--n1 != 0)                            // Есть еще слова?
      {                                         // Если слова есть:
        do                                      // Цикл инверсии.
          { ++p1; *p1 = ~*p1; }                 // Побитовая инверсия слова.
        while (--n1 != 0);                      // Конец цикла инверсии.
      }
      break;
    }
  }
  while ((++p1, --n1) != 0);                    // Конец цикла смены знака.
}

//      Прибавление 1:
//      1) Прибавлять к словам 1 вплоть до первого ненулевого результата.
//      2) Если последующих слов нет, а старшее слово равно 100..(побитово),
//         то добавить нулевое слово.
//         Если два старших слова результата равны 11.. и 100..(побитово),
//         то удалить старшее слово.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMInc (                       // Сложение p1 = p1 + 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1++);                  // Число слов.
  size_t n = n1;                                // Счетчик слов.

  if (n)                                        // Есть хотя бы одно слово.
  {
    do                                          // Цикл прибавления 1.
    {
      CBNL lp;                                  // Оптимизация слова.
      if ((*p1 = lp = *p1 + 1) != 0)            // Прибавление 1.
      {                                         // Получено ненулевое слово.
        if (--n != 0)                           // Есть еще слова?
        {                                       // Если осталось 1 слово
          if (--n != 0) return (n1);            // и оно лишнее, то удаление.
          return (n1 - (p1 [1] == (lp >> (BITS-1))));
        }                                       // Если больше слов нет, то
        if (lp != CBNL_MIN) return (n1);        // проверка переполнения и
        p1 [1] = 0; return (n1 + 1);            // добавление старшего слова.
      }
    }
    while ((++p1, --n) != 0);                   // Конец цикла прибавления 1.
  }
  else { *p1 = 1; n1 = 1; }                     // Нормализация пустого числа.

  return (n1);                                  // Все слова нулевые.
}
//#define cBigNumberMInc(p1)    (size_t)(*(p1)=_cBigNumberMInc(p1))

//      Вычитание 1:
//      1) Вычитать из слов 1 вплоть до первого результата, отличного от ~0.
//      2) Если последующих слов нет, а старшее слово равно 011..(побитово),
//         то добавить единичное слово.
//         Если два старших слова результата равны 00.. и 011..(побитово),
//         то удалить старшее слово.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMDec (                       // Вычитание p1 = p1 - 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1++);                  // Число слов.
  size_t n = n1;                                // Счетчик слов.

  if (n)                                        // Есть хотя бы одно слово.
  {
    do                                          // Цикл вычитания 1.
    {
      CBNL lp;                                  // Оптимизация слова.
      if ((*p1 = lp = *p1 - 1) != ~(CBNL)0)     // Вычитание 1.
      {                                         // Получено неединичное слово.
        if (--n != 0)                           // Есть еще слова?
        {                                       // Если осталось 1 слово
          if (--n != 0) return (n1);            // и оно лишнее, то удаление.
          return (n1 - (p1 [1] == (lp >> (BITS-1))));
        }                                       // Если больше слов нет, то
        if (lp != CBNL_MAX) return (n1);        // проверка переполнения и
        p1 [1] = ~(CBNL)0; return (n1 + 1);     // добавление старшего слова.
      }
    }
    while ((++p1, --n) != 0);                   // Конец цикла вычитания 1.
  }
  else { *p1 = -1; n1 = 1; }                    // Нормализация пустого числа.

  return (n1);                                  // Все слова единичные.
}
//#define cBigNumberMDec(p1)    (size_t)(*(p1)=_cBigNumberMDec(p1))

//      Сдвиг влево выполняется последовательно с переносом
//      старшего разряда в последующее слово и формированием
//      еще одного слова, полученного расширением знакового
//      разряда старшего слова. Если два последних разряда
//      старшего слова не совпадают, то размер числа увеличивается
//      на 1, т.е. добавленное слово становится знаковым.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMMul2 (                      // Сдвиг p1 <<= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1++);                  // Число слов.
  size_t n = n1;                                // Счетчик слов.
  CBNL num = 0;                                 // Слово до сдвига.

  if (n)
  do                                            // Цикл сдвига слов.
  {
    CBNL pass = (unsigned CBNL)num >> (BITS-1); // Разряд из предыдущего слова.
    num = *p1;                                  // Текущее слово до сдвига.
    *p1++ = (num << 1) | pass;                  // Текущее слово после сдвига.
  }
  while (--n != 0);                             // Конец цикла сдвига слов.

  num >>= (BITS-2);                             // Расширение знака
  n1 += (num != (*p1 = num >> 1));              // при переполнении.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMMul2(p1)   (size_t)(*(p1)=_cBigNumberMMul2(p1))

//      Вариант сдвига влево с копированием.

size_t  _cBigNumberMul2 (                       // Сдвиг p = p1 << 1.
                const   CBPTR(CBNL) p1,         // Операнд.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  p++;
  CBNL num = 0;                                 // Слово до сдвига.
  size_t n = n1;                                // Счетчик слов.

  if (n)
  do                                            // Цикл сдвига слов.
  {
    CBNL pass = (unsigned CBNL)num >> (BITS-1); // Разряд из предыдущего слова.
    num = *p1++;                                // Текущее слово до сдвига.
    *p++ = (num << 1) | pass;                   // Текущее слово после сдвига.
  }
  while (--n != 0);                             // Конец цикла сдвига слов.

  num >>= (BITS-2);                             // Расширение знака
  n1 += (num != (*p = num >> 1));               // при переполнении.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMul2(p1,p)  (size_t)(*(p)=_cBigNumberMul2(p1,p))

//      Сдвиг вправо выполняется последовательно с переносом
//      младшего разряда в предыдущее слово.
//      Сдвиг старшего слова знаковый, остальных - беззнаковый.
//      Если до сдвига все разряды старшего слова совпадают,
//      то старшее слово результата удаляется.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMDiv2 (                      // Сдвиг p1 >>= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n = n1;                                // Счетчик слов.
  p1 += n;                                      // Старшее слово.

  if (n)                                        // Есть слова?
  {
    if (--n != 0)                               // Более одного слова.
    {
      CBNL num = *p1;                           // Старшее слово до сдвига.
      n1 -= (num == (*p1-- = (num >> 1)));      // Сдвиг старшего слова и его
                                                // удаление, если 0 или ~0.
      do                                        // Цикл сдвига слов.
      {
        CBNL pass = num << (BITS-1);            // Разряд из следующего слова.
        num = *p1;                              // Текущее слово до сдвига.
        *p1-- = ((unsigned CBNL)num >> 1) | pass;
      }                                         // Текущее слово после сдвига.
      while (--n != 0);                         // Конец цикла сдвига слов.
    }
    else                                        // Только одно слово.
    {
      (*p1) >>= 1;                              // Сдвиг.
    }
  }
  return (n1);                                  // Число слов.
}
//#define cBigNumberMDiv2(p1)   (size_t)(*(p1)=_cBigNumberMDiv2(p1))

//      Вариант сдвига вправо с копированием.

size_t  _cBigNumberDiv2 (                       // Сдвиг p = p1 << 1.
                const   CBPTR(CBNL) p1,         // Операнд.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n = n1;                                // Счетчик слов.
  p1 += n;                                      // Старшее слово.
  p  += n;                                      // Старшее слово.

  if (n)                                        // Есть слова?
  {
    if (--n != 0)                               // Более одного слова.
    {
      CBNL num = *p1--;                         // Старшее слово до сдвига.
      n1 -= (num == (*p-- = (num >> 1)));       // Сдвиг старшего слова и его
                                                // удаление, если 0 или ~0.
      do                                        // Цикл сдвига слов.
      {
        CBNL pass = num << (BITS-1);            // Разряд из следующего слова.
        num = *p1--;                            // Текущее слово до сдвига.
        *p-- = ((unsigned CBNL)num >> 1) | pass;// Текущее слово после сдвига.
      }
      while (--n != 0);                         // Конец цикла сдвига слов.
    }
    else                                        // Только одно слово.
    {
      *p = (*p1) >> 1;                          // Сдвиг.
    }
  }
  return (n1);                                  // Число слов.
}
//#define cBigNumberDiv2(p1,p)  (size_t)(*(p)=_cBigNumberDiv2(p1,p))

//================================================
//      Подготовка таблицы сдвигов.
//================================================

//      Число нормализуется, далее в том же буфере после числа
//      формируется таблица сдвигов на 1..ns-1 с шагом *p + 2.
//      Функция всегда выдает нормализованное число и
//      нормализованные сдвиги; при этом незадействованные старшие
//      слова заполняются расширениями знаковых разрядов.
//      После этого число может участвовать в оптимизированных
//      операциях, использующих таблицу сдвигов.
//      ns = BITS   строит полную таблицу сдвигов, как inline cBigNumberTab()
//      ns = BITS/2 строит половинную таблицу сдвигов для деления

void    _cBigNumberTab (                        // Подготовка таблицы сдвигов.
                        EXPTR(CBNL) p,          // Число в буфере размера
                        CBNC        ns          // (max (*p, 1) + 2) * ns + 1.
        )                                       // Буфер заполняется сдвигами
{                                               // p << 1..ns-1, шаг *p + 2.
  size_t n = cBigNumberFit (p);                 // Число нормализованных слов.
  p [n + 1] = p [n] >> (BITS-1);                // Расширение знака.
  n += 2;
  EXPTR(CBNL) pp = p;                           // Рабочий указатель.
  while (--ns > 0)                              // Цикл сдвигов.
  {
    pp += n;
    cBigNumberMul2 (p, pp);                     // Сдвиг числа на бит.
    p = pp;
  }                                             // Конец цикла по словам.
}
//#define cBigNumberTab(p1,ns)  (_cBigNumberTab(p1,BITS))

//================================================
//      Логические функции.
//================================================

//      Длина чисел уравнивается путем расширения
//      знакового разряда более короткого числа.
//      Полученные слова обрабатываются пословно.
//
//      Особенности реализации:
//      - Предполагается, что второй операнд не длиннее первого.
//      - Для целей оптимизации вместо фактического расширения
//        знакового разряда применяется алгоритмический эквивалент.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованное число, за исключением случая, когда в операндах
//      нет ни одного слова - тогда результат будет таким же.

size_t  _cBigNumberXor  (                       // Сложение mod2 p = p1 ^ p2.
                const   CBPTR(CBNL) p1,         // Операнд.
                const   CBPTR(CBNL) p2,         // Операнд (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Возврат, если 0 слов.

  {
    CBNL lp2 = 0;                               // Текущее слово p2.

//      Обработка слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do { *p++ = *p1++ ^ (lp2 = *p2++); }    // Цикл по p1, p2.
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Обработка остатка p1, если p1 длиннее p2.

    {
      lp2 >>= (BITS-1);                         // Знаковый разряд p2.
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        do { *p++ = *p1++ ^ lp2; }              // Цикл по p1.
        while (--n != 0);                       // Конец цикла по p1.
      }
    }
    --p;                                        // Подготовка указателя.
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    CBNL pass;                                  // Старшее слово.
    CBNL lp;                                    // Предыдущее слово.
    size_t n = n1;                              // Число слов.
    if (n)                                      // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      lp = *p;                                  // слова все 0 или все 1, то
      do continue;                              // удаляется старшее слово.
      while (--n != 0 &&
        (pass = lp, lp = p [-1], --p, pass == (lp >> (BITS-1))));
    }                                           // Если ни одного слова нет,
    else { p [1] = 0; }                         // добавляется нулевое слово.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberXor(p1,p2,p) (size_t)(*(p)=_cBigNumberXor(p1,p2,p))

size_t  _cBigNumberAnd  (                       // Конъюнкция p = p1 & p2.
                const   CBPTR(CBNL) p1,         // Операнд.
                const   CBPTR(CBNL) p2,         // Операнд (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Возврат, если 0 слов.

  {
    CBNL lp2 = 0;                               // Текущее слово p2.

//      Обработка слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do { *p++ = *p1++ & (lp2 = *p2++); }    // Цикл по p1, p2.
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Обработка остатка p1, если p1 длиннее p2.

    {
      lp2 >>= (BITS-1);                         // Знаковый разряд p2.
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        do { *p++ = *p1++ & lp2; }              // Цикл по p1.
        while (--n != 0);                       // Конец цикла по p1.
      }
    }
    --p;                                        // Подготовка указателя.
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    CBNL pass;                                  // Старшее слово.
    CBNL lp;                                    // Предыдущее слово.
    size_t n = n1;                              // Число слов.
    if (n)                                      // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      lp = *p;                                  // слова все 0 или все 1, то
      do continue;                              // удаляется старшее слово.
      while (--n != 0 &&
        (pass = lp, lp = p [-1], --p, pass == (lp >> (BITS-1))));
    }                                           // Если ни одного слова нет,
    else { p [1] = 0; }                         // добавляется нулевое слово.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberAnd(p1,p2,p) (size_t)(*(p)=_cBigNumberAnd(p1,p2,p))

size_t  _cBigNumberOr  (                        // Дизъюнкция p = p1 & p2.
                const   CBPTR(CBNL) p1,         // Операнд.
                const   CBPTR(CBNL) p2,         // Операнд (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Возврат, если 0 слов.

  {
    CBNL lp2 = 0;                               // Текущее слово p2.

//      Обработка слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do { *p++ = *p1++ | (lp2 = *p2++); }    // Цикл по p1, p2.
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Обработка остатка p1, если p1 длиннее p2.

    {
      lp2 >>= (BITS-1);                         // Знаковый разряд p2.
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        do { *p++ = *p1++ | lp2; }              // Цикл по p1.
        while (--n != 0);                       // Конец цикла по p1.
      }
    }
    --p;                                        // Подготовка указателя.
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    CBNL pass;                                  // Старшее слово.
    CBNL lp;                                    // Предыдущее слово.
    size_t n = n1;                              // Число слов.
    if (n)                                      // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      lp = *p;                                  // слова все 0 или все 1, то
      do continue;                              // удаляется старшее слово.
      while (--n != 0 &&
        (pass = lp, lp = p [-1], --p, pass == (lp >> (BITS-1))));
    }                                           // Если ни одного слова нет,
    else { p [1] = 0; }                         // добавляется нулевое слово.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberOr(p1,p2,p)  (size_t)(*(p)=_cBigNumberOr(p1,p2,p))

//================================================
//      Функции сложения и вычитания.
//================================================

//      Длина чисел уравнивается путем расширения
//      знакового разряда более короткого числа.
//      Полученные слова складываются (вычитаются) пословно с
//      обработкой переносов (займов) из одного слова в другое.
//
//      Особенности реализации:
//      - Предполагается, что второй операнд не длиннее первого.
//      - Для целей оптимизации вместо фактического расширения
//        знакового разряда применяется алгоритмический эквивалент.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованное число, за исключением случая, когда в операндах
//      нет ни одного слова - тогда результат будет таким же.

size_t  _cBigNumberAdd  (                       // Сложение p = p1 + p2.
                const   CBPTR(CBNL) p1,         // Слагаемое.
                const   CBPTR(CBNL) p2,         // Добавляемое (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Return if 0 words.

  unsigned CBNL pass = 0;                       // Перенос в следующее слово p.
        // перенос располагается в старшем бите pass
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
  {
    CBNL lp1 = 0;                               // Текущее слово p1.
    CBNL lp2 = 0;                               // Текущее слово p2.

//      Суммирование слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do                                      // Цикл по p1, p2.
        {
          lp1 = *p1++; lp2 = *p2++;
          pass = (~(*p++ = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
                                                           | (lp1 & lp2);
        }
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Перенос или заем по остатку p1, если p1 длиннее p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        const CBNL *pp = p1;                    // Оптимизация.
        if ((lp2 & CBNL_MIN) == 0)              // p2 неотрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1) & lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
        else                                    // p2 отрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1 - 1) | lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
      }
    }
    --p;                                        // Подготовка указателя.

//      Суммирование расширений знаковых разрядов p1, p2.
//      Полученное таким образом старшее слово p состоит только из 0 или 1.
//      Старшее слово p запоминается в pass.

    pass = (pass >> (BITS-1)) + ((lp1) >> (BITS-1)) + ((lp2) >> (BITS-1));
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    CBNL lp = *p;                               // Предыдущее слово.
    size_t n = n1;                              // Число слов, кроме старшего.
    if (n && (CBNL)pass == (lp >> (BITS-1)))    // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      do continue;                              // слова все 0 или все 1, то
      while (--n != 0 &&                        // удаляется старшее слово.
        (pass = lp, lp = p [-1], --p, (CBNL)pass == (lp >> (BITS-1))));
    }
    else { p [1] = pass; }                      // Запись старшего слова.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberAdd(p1,p2,p) (size_t)(*(p)=_cBigNumberAdd(p1,p2,p))

//      Операция вычитания реализована в двух вариантах:
//      обычное вычитание и вычитание со сменой знака.

size_t  _cBigNumberSub  (                       // Вычитание p = p1 - p2.
                const   CBPTR(CBNL) p1,         // Вычитаемое.
                const   CBPTR(CBNL) p2,         // Вычитатель (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Return if 0 words.

  unsigned CBNL pass = ~(unsigned CBNL)0;       // Перенос в следующее слово p.
        // перенос располагается в старшем бите pass
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
        // начальное значение обеспечивает прибавление единицы.
  {
    CBNL lp1 = 0;                               // Текущее слово p1.
    CBNL lp2 = ~(CBNL)0;                        // Текущее слово ~p2.

//      Суммирование слов p1, ~p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do                                      // Цикл по p1, p2.
        {
          lp1 = *p1++; lp2 = ~(*p2++);
          pass = (~(*p++ = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
                                                           | (lp1 & lp2);
        }
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Перенос или заем по остатку p1, если p1 длиннее p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        const CBNL *pp = p1;                    // Оптимизация.
        if ((lp2 & CBNL_MIN) == 0)              // p2 отрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1) & lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
        else                                    // p2 неотрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1 - 1) | lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
      }
    }
    --p;                                        // Подготовка указателя.

//      Суммирование расширений знаковых разрядов p1, p2~.
//      Полученное таким образом старшее слово p состоит только из 0 или 1.
//      Старшее слово p запоминается в pass.

    pass = (pass >> (BITS-1)) + ((lp1) >> (BITS-1)) + ((lp2) >> (BITS-1));
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    CBNL lp = *p;                               // Предыдущее слово.
    size_t n = n1;                              // Число слов, кроме старшего.
    if (n && (CBNL)pass == (lp >> (BITS-1)))    // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      do continue;                              // слова все 0 или все 1, то
      while (--n != 0 &&                        // удаляется старшее слово.
        (pass = lp, lp = p [-1], --p, (CBNL)pass == (lp >> (BITS-1))));
    }
    else { p [1] = pass; }                      // Запись старшего слова.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberSub(p1,p2,p) (size_t)(*(p)=_cBigNumberSub(p1,p2,p))

//      Вычитание со сменой знака.

size_t  _cBigNumberSubS (                       // Вычитание p = p2 - p1.
                const   CBPTR(CBNL) p1,         // Вычитатель.
                const   CBPTR(CBNL) p2,         // Вычитаемое (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Return if 0 words.

  unsigned CBNL pass = ~(unsigned CBNL)0;       // Перенос в следующее слово p.
        // перенос располагается в старшем бите pass
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
        // начальное значение обеспечивает прибавление единицы.
  {
    CBNL lp1 = ~(CBNL)0;                        // Текущее слово ~p1.
    CBNL lp2 = 0;                               // Текущее слово p2.

//      Суммирование слов ~p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do                                      // Цикл по p1, p2.
        {
          lp1 = ~(*p1++); lp2 = *p2++;
          pass = (~(*p++ = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
                                                           | (lp1 & lp2);
        }
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Перенос или заем по остатку p1, если p1 длиннее p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        const CBNL *pp = p1;                    // Оптимизация.
        if ((lp2 & CBNL_MIN) == 0)              // p2 отрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = ~(*pp++);
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1) & lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
        else                                    // p2 неотрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = ~(*pp++);
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1 - 1) | lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
      }
    }
    --p;                                        // Подготовка указателя.

//      Суммирование расширений знаковых разрядов ~p1, p2.
//      Полученное таким образом старшее слово p состоит только из 0 или 1.
//      Старшее слово p запоминается в pass.

    pass = (pass >> (BITS-1)) + ((lp1) >> (BITS-1)) + ((lp2) >> (BITS-1));
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    CBNL lp = *p;                               // Предыдущее слово.
    size_t n = n1;                              // Число слов, кроме старшего.
    if (n && (CBNL)pass == (lp >> (BITS-1)))    // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      do continue;                              // слова все 0 или все 1, то
      while (--n != 0 &&                        // удаляется старшее слово.
        (pass = lp, lp = p [-1], --p, (CBNL)pass == (lp >> (BITS-1))));
    }
    else { p [1] = pass; }                      // Запись старшего слова.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberSubS(p1,p2,p) (size_t)(*(p)=_cBigNumberSubS(p1,p2,p))

//================================================
//      Специализированные функции накопления.
//================================================


//      Число младших 0-слов + 1 (нереентерабельно, исключается).

#ifndef _CBIGNUM_MT
static  size_t  _cBigNumberSkip = 1;            // Число 0-слов + 1.
#else //_CBIGNUM_MT
#define _cBigNumberSkip 1
#endif//_CBIGNUM_MT

//      Функция подсчета младших 0-слов.

size_t _CBNL_C  cBigNumberSkipLow0 (            // Подсчет 0-слов.
                const   CBPTR(CBNL) p1          // Буфер с числом.
)                                               // Выдает число 0-слов + 1.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n = 1;                                 // Число 0-слов + 1.

  if (n1 != 0)
  do
  {
    if (p1 [n] != 0) break;                     // Нашли ненулевое слово.
    n++;
  }
  while (--n1 != 0);

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = n;                          // Число 0-слов + 1.
#endif//_CBIGNUM_MT

  return (n);                                   // Число 0-слов + 1.
}

//      Функция подсчета младших нулевых слов и копирования с их пропуском.
//
//      Функция не требует нормализации операнда, но возвращает
//      нормализованный результат, если операнд не 0.
//
//      Если операнд 0, нормализованный или не нормализованный, то функция
//      создает НЕ нормализованный 0 из 0 слов и возвращает 0.

size_t _CBNL_C  cBigNumberCopySkipLow0 (        // Сдвиг p = p1 >> exwords(p1).
                const   CBPTR(CBNL) p1,         // Число для сдвига.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p могут совпадать.
                                                // Выдает число 0-слов.
{
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.

//      Нормализация.

  if (n1)                                       // Если в старшем слове и в
  {                                             // старшем бите предыдущего
    CBNL pass, lp = p1 [n1];                    // слова все 0 или все 1, то
    do continue;                                // удаляется старшее слово.
    while (--n1 != 0 &&
        (pass = lp, lp = p1 [n1], pass == (lp >> (BITS-1))));
    ++n1; ++p1;

//      Пропускаем младшие 0-слова и копируем.

    size_t k1 = 0;                              // Число младших 0-слов.
    do                                          // Пропуск 0-слов.
    {
      if (p1 [k1] != 0)                         // Найдено ненулевое слово.
      {
        p1 += k1;                               // Сдвиг.
        *p++ = (CBNL)n1;                        // Число слов.
        do                                      // Цикл копирования слов.
          { *p++ = *p1++; }                     // Копирование слова.
        while (--n1 != 0);                      // Конец цикла копирования.
        return (k1);                            // Число младших 0-слов.
      }
      k1++;                                     // Подсчет младших 0-слов
    }
    while (--n1 != 0);
  }

//      Выдаем НЕ нормализованный 0 из 0 слов, если все слова нулевые.

  *p = 0;                                       // НЕ нормализованный 0
  return (0);                                   // из 0 слов.
}

#ifndef _CBIGNUM_ASM                            // Если не в Cbignumf.cpp

//      Специализированное сложение со сдвигом второго числа
//      влево на указанное число слов. Применяется при умножении.
//
//      Для целей оптимизации предполагается, что:
//      - Размер первого числа не менее, чем размер второго числа
//        после сдвига и не менее, чем размер результата.
//      - Размер второго числа до сдвига больше 0.
//      Перед сложением надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов во втором слагаемом.
//
//      Функция не требует нормализации операндов, не проводит
//      нормализацию результата и не меняет размер первого числа.

void   _CBNL_C  cBigNumberMAddM (               // Сложение p1 += p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Слагаемое, потом результат.
                const   CBPTR(CBNL) p2,         // Слагаемое размера <=*p1-k2.
                        size_t      k2          // Сдвиг слагаемого влево.
        )                                       // p1, p2 могут совпадать.
{
  const CBPTR(CBNL) pp = p1 + (size_t)(*p1);    // Последнее слово p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов p2.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert ((size_t)(*p1) >= n2 + k2);            // Проверка размера.
  assert (n2 >= _cBigNumberSkip);               // Проверка размера.
  p1 += k2;                                     // Масштабирование p2.

  unsigned CBNL pass = 0;                       // Перенос: 0 или 1.
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
  {
    const CBPTR(CBNL) ppn = p1 + n2;            // Для последнего слова p2.
    p1 += _cBigNumberSkip;                      // Коррекция начала p1.
    p2 += _cBigNumberSkip;                      // Коррекция начала p2.
    CBNL lp1;                                   // Текущее слово p1.
    CBNL lp2;                                   // Текущее слово p2.

//      Суммирование слов p1, p2.
//      Операторы цикла вычисляют логическое выражение:
//      pass = ((~(*p1 = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
//                                                       | (lp1 & lp2))
//      Логическое выражение расписано в виде цепочки присваиваний:
//      pass += (lp1 + lp2)     // *p1 = pass
//      lp1  = ~(lp1 ^ lp2)     // Присваивание lp1 высвобождает регистр.
//      pass = ~(pass | lp1)    // Используется правило де Моргана
//      pass |= (lp1 & lp2)     // и тождество a & b = ~(a^b) & b.
//      Присваивания разбавлены проверками условия цикла и приращениями
//      указателей для оптимизации загрузки конвейеров Pentium.

    for (;;)                                    // Цикл по p1, p2.
    {
      lp1 = *p1;        lp2 = *p2;              // Текущие слова p1, p2.
      pass += lp1;      lp1 ^= lp2;
      pass += lp2;      lp1 = ~lp1;
      *p1 = pass;       pass |= lp1;
      lp1 &= lp2;       pass = ~pass;
      ++p2;             pass |= lp1;
      if (p1 >= ppn)    break;
      ++p1;             pass >>= (BITS-1);
    }
    if ((CBNL)(lp2 ^= pass) >= 0) return;       // Переноса или займа нет.
  }

//      Перенос или заем по остатку p1, если p1 длиннее p2.
//      Предусловие: p1 указывает на последнее полученное слово,
//                   pass содержит перенос в старшем бите.

  {
    CBNL lp1;                                   // Текущее слово p1.
    if ((CBNL)pass < 0)                         // p2 неотрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 + 1) & lp1) < 0);
    }
    else                                        // p2 отрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 - 1) | lp1) >= 0);
    }
  }
}

//      Специализированное вычитание со сдвигом второго числа
//      влево на указанное число слов. Применяется при умножении.
//
//      Для целей оптимизации предполагается, что:
//      - Размер первого числа не менее, чем размер второго числа
//        после сдвига и не менее, чем размер результата.
//      - Размер второго числа до сдвига больше 0.
//      Перед вычитанием надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов во втором слагаемом.
//
//      Функция не требует нормализации операндов, не проводит
//      нормализацию результата и не меняет размер первого числа.

void   _CBNL_C  cBigNumberMSubM (               // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат.
                const   CBPTR(CBNL) p2,         // Вычитатель размера <=*p1-k2.
                        size_t      k2          // Сдвиг вычитаемого влево.
        )                                       // p1, p2 могут совпадать.
{
  const CBPTR(CBNL) pp = p1 + (size_t)(*p1);    // Последнее слово p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов p2.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert ((size_t)(*p1) >= n2 + k2);            // Проверка размера.
  assert (n2 >= _cBigNumberSkip);               // Проверка размера.
  p1 += k2;                                     // Масштабирование p2.

  CBNL pass = 0;                                // Перенос: 0 или 1.
        // CBNL обеспечивает сдвиг pass >> с расширением знака.
  {
    const CBPTR(CBNL) ppn = p1 + n2;            // Для последнего слова p2.
    p1 += _cBigNumberSkip;                      // Коррекция начала p1.
    p2 += _cBigNumberSkip;                      // Коррекция начала p2.
    CBNL lp1;                                   // Текущее слово p1.
    CBNL lp2;                                   // Текущее слово p2.

//      Вычитание слов p1, p2.
//      Операторы цикла вычисляют логическое выражение:
//      pass = (((*p1 = (pass >> (BITS-1)) + lp1 - lp2) | (lp1 ^ lp2))
//                                                     & (~lp1 | lp2))
//      Логическое выражение расписано в виде цепочки присваиваний:
//      pass += (lp1 - lp2)     // *p1 = pass
//      pass |= (lp1 ^= lp2)    // Присваивание lp1 высвобождает регистр.
//      pass = ~pass;           // Используется правило Де Моргана
//      pass |= (lp1 & ~lp2)    // и тождество a & ~b = (a^b) & ~b.
//      pass = ~pass;
//      Присваивания разбавлены проверками условия цикла и приращениями
//      указателей для оптимизации загрузки конвейеров Pentium.

    for (;;)                                    // Цикл по p1, p2.
    {
      lp1 = *p1;        lp2 = *p2;              // Текущие слова p1, p2.
      pass += lp1;      lp1 ^= lp2;
      pass -= lp2;      lp2 = ~lp2;
      *p1 = pass;       pass |= lp1;
      lp1 &= lp2;       pass = ~pass;
      ++p2;             pass |= lp1;
      if (p1 >= ppn)    break;
      ++p1;             pass >>= (BITS-1);
                        pass = ~pass;
    }
    if ((CBNL)(lp2 ^= pass) >= 0) return;       // Переноса или займа нет.
  }

//      Перенос или заем по остатку p1, если p1 длиннее p2.
//      Предусловие: p1 указывает на последнее полученное слово,
//                   pass содержит перенос в старшем бите.

  {
    CBNL lp1;                                   // Текущее слово p1.
    if ((CBNL)pass < 0)                         // p2 отрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 + 1) & lp1) < 0);
    }
    else                                        // p2 неотрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 - 1) | lp1) >= 0);
    }
  }
}

//      Специализированное вычитание со сдвигом второго числа
//      на указанное число слов. Применяется при делении.
//
//      Размер вычитателя определяется относительно вычитаемого путем
//      вычитания сдвига, т.е. слово размера 0 игнорируется и читается
//      только массив дополнительного кода, начиная со слова 1.
//      ПРИМЕЧАНИЕ: в версии до 2.2 функция читала размер из слова 0,
//                  который мог быть меньше рассчитанного. Аналогично
//                  работает inline функция cBigNumberMSubD.
//
//      Для целей оптимизации предполагается, что:
//      - Числа имеют одинаковый знак.
//      - Размер первого числа не менее, чем размер второго числа
//        после сдвига.
//      - Размер второго числа до сдвига больше 0.
//      - После вычитания число значащих бит в числе уменьшается.
//      - После вычитания знак числа не меняется,
//        кроме обнуления отрицательных чисел.
//      Перед вычитанием надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов в вычитаемом.
//
//      Альтернативный метод, доступный начиная с версии 2.2, определяет
//      размер второго числа относительно первого вычитаним сдвига,
//      игнорируюя размер в слове 0. Читается только дополнительный код.
//      ВНИМАНИЕ: Альтернативный метод доступен в _cBigNumberMSubD() как
//                опция компиляции. Inline функция cBigNumberMSubD() всегда
//                использует прежний метод.
//
//      Функция не требует нормализации операндов и всегда выдает
//      нормализованный результат, размер которого не превышает
//      размер вычитаемого числа после сдвига.

size_t _CBNL_C _cBigNumberMSubD (               // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат.
#ifndef _CBNL_TAB_FULL
                const   CBPTR(CBNL) p2,         // Вычитатель размера <=*p1-k2.
#else //_CBNL_TAB_FULL
                const   CBNL*       p2,         // Вычитатель размера *p1-k2.
#endif//_CBNL_TAB_FULL
                        size_t      k2          // Сдвиг вычитателя влево.
        )                                       // p1, p2 могут совпадать.
{
#ifndef _CBNL_TAB_FULL                          // Стабильный метод.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов p2.
  assert ((p1 [(size_t)(*p1)] ^ p2 [n2]) >= 0); // Проверка знаков.
  assert ((size_t)(*p1) >= n2 + k2);            // Проверка размера.
#else //_CBNL_TAB_FULL                          // Альтернативный метод.
  size_t n2 = (size_t)(*p1) - k2;               // Число слов p2.
#endif//_CBNL_TAB_FULL
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert (n2 >= _cBigNumberSkip);               // Проверка размера.
  p1 += k2;                                     // Масштабирование p2.

  CBNL pass = 0;                                // Заем: 0 или -1.
        // CBNL обеспечивает сдвиг pass >> с расширением знака.
  {
    const CBPTR(CBNL) ppn = p1 + n2;            // Для последнего слова p2.
    p1 += _cBigNumberSkip;                      // Коррекция начала p1.
    p2 += _cBigNumberSkip;                      // Коррекция начала p2.
    CBNL lp1;                                   // Текущее слово p1.
    CBNL lp2;                                   // Текущее слово p2.

//      Вычитание слов p1, p2.
//      Операторы цикла вычисляют логическое выражение:
//      pass = (((*p1 = (pass >> (BITS-1)) + lp1 - lp2) | (lp1 ^ lp2))
//                                                     & (~lp1 | lp2))
//      Логическое выражение расписано в виде цепочки присваиваний:
//      pass += (lp1 - lp2)     // *p1 = pass
//      pass |= (lp1 ^= lp2)    // Присваивание lp1 высвобождает регистр.
//      pass &=~(lp1 & ~lp2)    // Используется правило Де Моргана
//                              // и тождество a & ~b = (a^b) & ~b.
//      Присваивания разбавлены проверками условия цикла и приращениями
//      указателей для оптимизации загрузки конвейеров Pentium.

    for (;;)                                    // Цикл по p1, p2.
    {
      lp1 = *p1;        lp2 = *p2;              // Текущие слова p1, p2.
      pass += lp1;      lp1 ^= lp2;
      pass -= lp2;      lp2 = ~lp2;
      *p1 = pass;       lp2 &= lp1;
      if (p1 >= ppn)    break;
      lp2 = ~lp2;       pass |= lp1;
      ++p1;             pass &= lp2;
      ++p2;             pass >>= (BITS-1);
    }
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.
//      Предусловие: p1 указывает на последнее полученное слово,
//                   копия которого находится в pass.

  {
    size_t n1 = n2 + k2;

//      В цикле выполняются операции:
//      do continue;
//      while (--n1 != 0 &&
//              lp1 == (lp1 = pass, pass = p1 [-1], --p1, pass >> (BITS-1)));

    for (;;)
    {
      CBNL lp1;                                 // Старшее слово.
      CBNL lp2;                                 // Предыдущее слово.
      if (--n1 == 0)    break;                  // Осталось одно слово.
      lp2 = p1 [-1];    --p1;
      lp1 = pass;       pass = lp2;
      lp2 >>= (BITS-1);
      if (lp1 != lp2)   break;
    }
    return (n1 + 1);                            // Число слов p.
  }
}
//#define cBigNumberMSubD(p1,p2,k2) (size_t)(*(p1)=_cBigNumberMSubD(p1,p2,k2))

//      Специализированный сдвиг влево на 1 бит.
//      Применяется при умножении.
//
//      Предполагается, что число не равно 0.
//      Перед сдвигом надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов в буфере.
//
//      Сдвиг влево выполняется последовательно с переносом
//      старшего разряда в последующее слово и формированием
//      еще одного слова, полученного расширением знакового
//      разряда старшего слова. Если два последних разряда
//      старшего слова не совпадают, то размер числа увеличивается
//      на 1, т.е. добавленное слово становится знаковым.
//
//      Функция не требует нормализации операндов и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t _CBNL_C _cBigNumberMMul2M (              // Сдвиг p1 <<= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert (n1 >= _cBigNumberSkip);               // Проверка размера.

  const CBPTR(CBNL) pp = p1 + n1;               // Последнее слово p1.
  p1 += _cBigNumberSkip;                        // Первое ненулевое слово p1.
  CBNL num = 0;                                 // Слово до сдвига.
  do                                            // Цикл сдвига слов.
  {
    CBNL pass = (unsigned CBNL)num >> (BITS-1); // Разряд из предыдущего слова.
    num = *p1;                                  // Текущее слово до сдвига.
    *p1++ = (num << 1) | pass;                  // Текущее слово после сдвига.
  }
  while (p1 <= pp);                             // Цикл сдвига слов.

  num >>= (BITS-2);                             // Расширение знака
  n1 += (num != (*p1 = num >> 1));              // при переполнении.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMMul2M(p1)   (size_t)(*(p1)=_cBigNumberMMul2M(p1))

//      Специализированный сдвиг вправо на 1 бит.
//      Применяется при делении и вычислении квадратного корня.
//
//      Предполагается, что:
//      - Число не равно 0.
//      - Младший бит младшего ненулевого слова нулевой.
//      Перед сдвигом надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов в буфере.
//
//      Сдвиг вправо выполняется последовательно с переносом
//      старшего разряда в предыдущее слово.
//      Сдвиг старшего слова знаковый, остальных - беззнаковый.
//      Если до сдвига все разряды старшего слова совпадают,
//      то старшее слово результата удаляется.
//
//      Функция не требует нормализации операндов и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t _CBNL_C _cBigNumberMDiv2D (              // Сдвиг p1 >>= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert (n1 >= _cBigNumberSkip);               // Проверка размера.
  assert ((p1 [_cBigNumberSkip] & (CBNL)1)==0); // Проверка младшего бита.

  const CBPTR(CBNL) pp = p1 + _cBigNumberSkip;  // Первое ненулевое слово p1.
  p1 += n1;                                     // Старшее слово.
  CBNL num = *p1;                               // Старшее слово до сдвига.
  n1 -= (n1 > 1) & (num == (*p1-- = num >> 1)); // Сдвиг старшего слова и его
                                                // удаление, если 0 или ~0.
  while (p1 >= pp)                              // Цикл сдвига слов.
  {
    CBNL pass = num << (BITS-1);                // Разряд из следующего слова.
    num = *p1;                                  // Текущее слово до сдвига.
    *p1-- = ((unsigned CBNL)num >> 1) | pass;   // Текущее слово после сдвига.
  }                                             // Конец цикла сдвига слов.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMDiv2D(p1)   (size_t)(*(p1)=_cBigNumberMDiv2D(p1))

#endif//_CBIGNUM_ASM

//      Специальная функция вычитания беззнакого числа для деления.
//      0-слово должно быть предусмотроено в коде.

void   _CBNL_C  cBigNumberMSubMM (              // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат.
                const   CBPTR(CBNL) p2,         // Вычитатель размера < *p1-k2.
                        size_t      k2          // Сдвиг вычитаемого влево.
        )                                       // p1, p2 могут совпадать.
{
  (*(CBNL*)CBPTRBASE(p2))++;                    // Добавление 0-слова.
  cBigNumberMSubM (p1, p2, k2);                 // Вычитание.
  (*(CBNL*)CBPTRBASE(p2))--;                    // Удаление 0-слова.
}

//      Специализированный сдвиг числа на одно слово вправо для умножения.
//      Исходное число должно содержать, как минимум, два слова.

void    cBigNumberMShrM (                       // Сдвиг p1 >>= BITS.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  assert (n1 > 1);                              // Проверка.
  *p1 = (CBNL)--n1;
  do                                            // Цикл копирования слов.
    { p1 [1] = p1 [2]; p1++; }                  // Копирование слова.
  while ((CBNL)--n1 > 0);                       // Конец цикла копирования.
}

//      Сдвиг числа на одно слово влево для деления.
//      Исходное число должно содержать, как минимум, одно слово.

void    cBigNumberMShlD (                       // Сдвиг p1 <<= BITS.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  assert (n1 > 0);                              // Проверка.
  *p1 = (CBNL)(n1 + 1);
  do                                            // Цикл копирования слов.
    { p1 [n1 + 1] = p1 [n1]; }                  // Копирование слова.
  while ((CBNL)--n1 > 0);                       // Конец цикла копирования.
  p1 [1] = 0;
}

//      Функции быстрого накопления со сдвигом, оптимальные для
//      больших чисел, в особенности для большого накопителя.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddShl (                     // Сложение p1 += p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Слагаемое, потом результат
                                                // в буфере размера
                                                // max (*p1, *p2 + k2) + 2.
                const   CBPTR(CBNL) p2,         // Слагаемое.
                        size_t      k2          // Сдвиг слагаемого влево.
        )                                       // p1, p2 могут перекрываться.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigNumberFitTo (p1, n2 + k2 + 1);            // Денормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
  if (n2 > 0) cBigNumberMAddM (p1, p2, k2);     // Быстрое сложение.

  cBigNumberFit (p1);                           // Нормализация.
}

void    cBigNumberMSubShl (                     // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат
                                                // в буфере размера
                                                // max (*p1, *p2 + k2) + 2.
                const   CBPTR(CBNL) p2,         // Вычитатель.
                        size_t      k2          // Сдвиг вычитаемого влево.
        )                                       // p1, p2 могут перекрываться.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigNumberFitTo (p1, n2 + k2 + 1);            // Денормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
  if (n2 > 0) cBigNumberMSubM (p1, p2, k2);     // Быстрое вычитание.

  cBigNumberFit (p1);                           // Нормализация.
}

//================================================
//      Функции умножения, использующие только
//      операции сложения и вычитания.
//================================================

//      Специализированные функции умножения со сдвигом и накоплением.
//      В буфере множимого должна находится таблица сдвигов, полученная
//      функцией cBigNumberTab(). Метод эффективен, если размер
//      хотя бы одного операнда не превосходит _CBNL_KARATSUBA_MIN * 2.
//      Для лучшей производительности операнд большего размера следует
//      поставить первым, если только его размер не больше _CBNL_TAB_OPT.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMulShlTab (               // Умножение со сложением
                                                // p += p1 *p2 << k*BITS.
                const   CBPTR(CBNL) p1,         // Множимое и таблица сдвигов.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения с таблицей сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    n1 += 2;                                    // Шаг по таблице сдвигов.
#ifndef _CBIGNUM_TERNARY_MUL
    for (size_t k2 = 0; k2 != n2; k2++)         // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      CBNL mask = 1;                            // Маска для битов num.
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (;; pp1 += n1)                        // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMAddM (p, pp1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#else //_CBIGNUM_TERNARY_MUL
    CBNL num2 = p2 [n2], num1 = num2;           // Старший бит старшего слова.
    num2 <<= 1;                                 // Следующий бит.
    CBNL mode = 0;                              // 0=сложение, -1=вычитание.
    if ((num1 & num2) < 0)                      // Старшие биты все 1.
    {
      cBigNumberMAddM (p, p1, k + n2);          // Сложение со сдвигом n2.
      num1 = ~num1; num2 = ~num2;
      mode = ~(CBNL)0;                          // Режим вычитания.
    }
    p1 += n1 * BITS; p1 -= n1;                  // Начальный сдвиг.
    for (size_t k2 = n2; k2-- != 0;)            // Цикл по словам p2.
    {
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (size_t kb = BITS;; pp1 -= n1)        // Цикл по битам слова p2.
      {
        CBNL num = num1;                        // Текущий бит.
        num1 = num2;                            // 1-й следующий бит.
        if (kb != 2) num2 <<= 1;                // 2-й следующий бит.
        else num2 = (k2? p2 [k2]: 0L) ^ mode;   // Слово закончилось.
        if ((num | (num1 & num2) ) < 0)         // Критерий накопления.
        {
           if (mode == 0) cBigNumberMAddM (p, pp1, k + k2);
           else           cBigNumberMSubM (p, pp1, k + k2);
           if (num >= 0) { num1 = ~num1; num2 = ~num2; mode = ~mode; }
        }                                       // Смена режима.
        if (--kb == 0) break;                   // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#endif//_CBIGNUM_TERNARY_MUL
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

void    cBigNumberMSubMulShlTab (               // Умножение с вычитанием
                                                // p -= p1 *p2 << k*BITS.
                const   CBPTR(CBNL) p1,         // Множимое и таблица сдвигов.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения с таблицей сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    n1 += 2;                                    // Шаг по таблице сдвигов.
#ifndef _CBIGNUM_TERNARY_MUL
    for (size_t k2 = 0; k2 != n2; k2++)         // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      CBNL mask = 1;                            // Маска для битов num.
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (;; pp1 += n1)                        // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMSubM (p, pp1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#else //_CBIGNUM_TERNARY_MUL
    CBNL num2 = p2 [n2], num1 = num2;           // Старший бит старшего слова.
    num2 <<= 1;                                 // Следующий бит.
    CBNL mode = 0;                              // 0=вычитание, -1=сложение.
    if ((num1 & num2) < 0)                      // Старшие биты все 1.
    {
      cBigNumberMSubM (p, p1, k + n2);          // Вычитание со сдвигом n2.
      num1 = ~num1; num2 = ~num2;
      mode = ~(CBNL)0;                          // Режим сложения.
    }
    p1 += n1 * BITS; p1 -= n1;                  // Начальный сдвиг.
    for (size_t k2 = n2; k2-- != 0;)            // Цикл по словам p2.
    {
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (size_t kb = BITS;; pp1 -= n1)        // Цикл по битам слова p2.
      {
        CBNL num = num1;                        // Текущий бит.
        num1 = num2;                            // 1-й следующий бит.
        if (kb != 2) num2 <<= 1;                // 2-й следующий бит.
        else num2 = (k2? p2 [k2]: 0L) ^ mode;   // Слово закончилось.
        if ((num | (num1 & num2) ) < 0)         // Критерий накопления.
        {
           if (mode == 0) cBigNumberMSubM (p, pp1, k + k2);
           else           cBigNumberMAddM (p, pp1, k + k2);
           if (num >= 0) { num1 = ~num1; num2 = ~num2; mode = ~mode; }
        }                                       // Смена режима.
        if (--kb == 0) break;                   // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#endif//_CBIGNUM_TERNARY_MUL
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

//================================================
//      Функции умножения, использующие только
//      операции сложения, вычитания и сдвига,
//      но имеющие альтернативную реализацию,
//      если разрешено аппаратное умножение.
//================================================

#ifndef _CBIGNUM_HARDWARE_MUL

//      Специализированные функции умножения со сдвигом и накоплением.
//      Множимое иcпользуется, как рабочий буфер и будет портиться.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMulShl (                  // Умножение со сложением
                                                // p += p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения, не применяющий таблицу сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    --n2;
    size_t k2 = 0;
    for (; k2 != n2; k2++)                      // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      if (num == 0) continue;                   // Оптимизация.
      CBNL mask = 1;                            // Маска для битов num.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMAddM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
      cBigNumberMMul2M (p1);                    // Сдвиг множимого на бит.
      cBigNumberMShrM (p1);                     // Восстановление множимого.
    }                                           // Конец цикла по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Последнее слово p2.
      CBNL mask = (num != 0);                   // Маска для битов num.
      if (num > 0)                              // Старший бит num может
      do                                        // быть не 0 при p2 < 0.
        mask <<= 1;                             // Сдвигаем mask и num, пока
      while ((num <<= 1) > 0);                  // старший бит num равен 0.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMAddM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

void    cBigNumberMSubMulShl (                  // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения, не применяющий таблицу сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    --n2;
    size_t k2 = 0;
    for (; k2 != n2; k2++)                      // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      if (num == 0) continue;                   // Оптимизация.
      CBNL mask = 1;                            // Маска для битов num.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMSubM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
      cBigNumberMMul2M (p1);                    // Сдвиг множимого на бит.
      cBigNumberMShrM (p1);                     // Восстановление множимого.
    }                                           // Конец цикла по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Последнее слово p2.
      CBNL mask = (num != 0);                   // Маска для битов num.
      if (num > 0)                              // Старший бит num может
      do                                        // быть не 0 при p2 < 0.
        mask <<= 1;                             // Сдвигаем mask и num, пока
      while ((num <<= 1) > 0);                  // старший бит num равен 0.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMSubM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

//      Специализированные функции умножения со сдвигом и накоплением.
//      Для ускорения применяется метод Карацубы или метод умножения
//      по частям, а также строятся временные таблицы сдвигов.
//      Для лучшей производительности операнд существенно большего
//      размера рекомендуется поставить первым.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMulShlKar (               // Умножение со сложением
                                                // p += p1 *p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3 +
                                                // *p2 < _CBNL_TAB_MIN?
                                                //  (min (*p1, _CBNL_TAB_HIGH)
                                                //   + 2) * (BITS - 1).
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k + 1)
                                                //                        + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*p2);                    // Число слов.

//      Проверка применимости метода Карацубы.

#ifdef  _CBIGNUM_KARATSUBA_MUL
  if (n1 > _CBNL_KARATSUBA_MIN && n2 > _CBNL_KARATSUBA_MIN)
  {

//      Умножение большого 1-го операнда по частям.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения p2 при рекурсивном вызове.

    while (n1 > n2 * 2 - n2 / 4)                // Проверка размера.
    {
      CBNL lp = p1 [n1 -= n2];                  // Сохранение затираемого
      p1 [n1] = (CBNL) n2;                      // слова и запоминание размера.
      cBigNumberMAddMulShlKar (p1 + n1, p2, k + n1, p);
      p1 [n1] = lp;                             // Восстановление слова.
      p1 [n1 + 1] = 0; n1 += (lp < 0);          // Добавление старшего 0-слова.
      p1 [0] = (CBNL) n1;                       // Размер последней части.
    }

//      Умножение операндов близкого размера по методу Карацубы.

    size_t n = (n1 >= n2? n1: n2 - 1) / 2;      // Размер младшей части.

//      ПРИМЕЧАНИЕ: Чтобы не было переполнения p в редком специальном
//                  случае, когда p1 вдвое короче p2 или еще меньше,
//                  старшая часть p2 должна быть длиннее младшей части p2.

    cBigTemp c12; c12.checkexpand (n * 2 + 5);
    EXPTR(CBNL) p12 = EXPTRTYPE(c12);           // Буфер для умножения.

    cBigTemp c1; c1.checkexpand (n + 2);
    cBigTemp c2; c2.checkexpand (n + 4);
    cBigNumberCopyShr (p2, n, EXPTRTYPE(c2));   // Старшая часть p2 в c2.

//      Размер p1 может быть n или меньше если p1 вдвое или более короче p2.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения c2 при рекурсивном вызове.

    if (n1 > n)
    {
      cBigNumberCopyShr (p1, n, EXPTRTYPE(c1)); // Старшая часть p1 в c1.
      CBNL lp = p1 [n];                         // Сохранение затираемого
      p1 [n] = (CBNL)(n1 - n);                  // слова и запоминание размера.
      p12 [0] = 0;                              // Очистка буфера умножения.
      cBigNumberMAddMulShlKar (p1 + n, EXPTRTYPE(c2), 0, p12);
                                                // Умножение c1 * c2.
      cBigNumberMAddShl (p, p12, k + n * 2);    // Накопление c1 * c2.
      cBigNumberMSubShl (p, p12, k + n);        // Накопление c1 * c2.
      p1 [n] = lp;                              // Восстановление слова.
      p1 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p1 [0] = (CBNL)(n + (lp < 0));            // Младшая часть p1.
      cBigNumberMAddShl (EXPTRTYPE(c1), p1, 0); // Сложение c1 + p1.
    }
    else
      cBigNumberCopy (p1, EXPTRTYPE(c1));       // Копирование p1 в c1.

//      Размер p2 не может быть n или меньше.

    assert (n2 > n);
    {
      size_t nc2 = c2.length() + 1;             // Добавление старшего 0-слова.
      c2.item (0) = (CBNL) nc2;
      ((EXPTR(CBNL)) EXPTRTYPE(c2)) [nc2] = 0;

      CBNL lp = p2 [n + 1];                     // Сохранение слова.
      p2 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p2 [0] = (CBNL)(n + 1);                   // Младшая часть p2.
      cBigNumberMAddShl (EXPTRTYPE(c2), p2, 0); // Сложение c2 + p2.
      p2 [n + 1] = lp;                          // Восстановление слова.

      p2 [0] = (CBNL) n;                        // Удаление старшего 0-слова.
      p12 [0] = 0;                              // Очистка буфера умножения.
      cBigNumberMAddMulShlKar (p1, p2, 0, p12); // Умножение p1 * p2.
      p2 [0] = (CBNL) n2;                       // Восстановление исходного p2.

      c2.item (0) = (CBNL)(c2.length() - (c2.hiword() == 0));
                                                // Удаление старшего 0-слова.
      cBigNumberCopy (CBPTRTYPE(c1), p1);       // Накопление (c1+p2)*(c2+p2).
      cBigNumberMAddMulShlKar (p1, EXPTRTYPE(c2), k + n, p);

      cBigNumberMSubShl (p, p12, k + n);        // Накопление p1 * p2.
      cBigNumberMAddShl (p, p12, k);            // Накопление p1 * p2.
    }

    return;
  }
#endif//_CBIGNUM_KARATSUBA_MUL

//      Умножение 1-го операнда по частям, если 2-ой операнд небольшой.
//
//      Старшая часть может быть положительной или отрицательной, но младшие
//      части всегда положительные, поэтому добавляем к ним старшее 0-слово.
//      Старшая и последующие части содержат _CBNL_TAB_OPT + 1 слов,
//      включая старшее 0-слово для всех частей кроме старшей, самая
//      младшая часть может содержать до _CBNL_TAB_HIGH слов вместе со
//      добавочным старшим 0-словом.
//
//      Алгоритм выделяет части без копирования.

#ifdef  _CBIGNUM_BLOCK_MUL
  if (n1 > _CBNL_TAB_HIGH)
  {                                             // Учет старшего слова
    --n1;                                       // старшей части.
    do                                          // Цикл по частям.
    {
      n1 -= _CBNL_TAB_OPT;                      // Размер всех младших частей.
      CBNL lp = p1 [n1];                        // Сохранение затираемого
      p1 [n1] = _CBNL_TAB_OPT + 1;              // слова и запоминание размера.
#ifdef  _CBIGNUM_SHIFTTAB_MUL
      if (n2 >= _CBNL_TAB_MIN) {                // Нужна таблица сдвигов?
        cBigNumberTab (p1 + n1);                // Подготовка таблицы сдвигов.
        cBigNumberMAddMulShlTab (p1 + n1, p2, k + n1, p);
      } else
#endif//_CBIGNUM_SHIFTTAB_MUL
        cBigNumberMAddMulShl (p1 + n1, p2, k + n1, p);
      p1 [n1 + 1] = 0;                          // Добавление старшего 0-слова.
      p1 [n1] = lp;                             // Восстановление слова.
    }
    while (n1 >= _CBNL_TAB_HIGH);
    p1 [0] = (CBNL)(n1 + 1);                    // Размер последней части.
  }
#endif//_CBIGNUM_BLOCK_MUL

//      Умножение последней части.

#ifdef  _CBIGNUM_SHIFTTAB_MUL
#ifdef  _CBIGNUM_BLOCK_MUL
  if (n2 >= _CBNL_TAB_MIN) {                    // Нужна таблица сдвигов?
#else
  if (n2 >= _CBNL_TAB_MIN && n1 <= _CBNL_TAB_HIGH) {
#endif//_CBIGNUM_BLOCK_MUL
    cBigNumberTab (p1);                         // Подготовка таблицы сдвигов.
    cBigNumberMAddMulShlTab (p1, p2, k, p);
  } else
#endif//_CBIGNUM_SHIFTTAB_MUL
    cBigNumberMAddMulShl (p1, p2, k, p);
}

void    cBigNumberMSubMulShlKar (               // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3 +
                                                // *p2 < _CBNL_TAB_MIN?
                                                //  (min (*p1, _CBNL_TAB_HIGH)
                                                //   + 2) * (BITS - 1).
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k + 1)
                                                //                        + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*p2);                    // Число слов.

//      Проверка применимости метода Карацубы.

#ifdef  _CBIGNUM_KARATSUBA_MUL
  if (n1 > _CBNL_KARATSUBA_MIN && n2 > _CBNL_KARATSUBA_MIN)
  {

//      Умножение большого 1-го операнда по частям.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения p2 при рекурсивном вызове.

    while (n1 > n2 * 2 - n2 / 4)                // Проверка размера.
    {
      CBNL lp = p1 [n1 -= n2];                  // Сохранение затираемого
      p1 [n1] = (CBNL) n2;                      // слова и запоминание размера.
      cBigNumberMSubMulShlKar (p1 + n1, p2, k + n1, p);
      p1 [n1] = lp;                             // Восстановление слова.
      p1 [n1 + 1] = 0; n1 += (lp < 0);          // Добавление старшего 0-слова.
      p1 [0] = (CBNL) n1;                       // Размер последней части.
    }

//      Умножение операндов близкого размера по методу Карацубы.

    size_t n = (n1 >= n2? n1: n2 - 1) / 2;      // Размер младшей части.

//      ПРИМЕЧАНИЕ: Чтобы не было переполнения p в редком специальном
//                  случае, когда p1 вдвое короче p2 или еще меньше,
//                  старшая часть p2 должна быть длиннее младшей части p2.

    cBigTemp c12; c12.checkexpand (n * 2 + 5);
    EXPTR(CBNL) p12 = EXPTRTYPE(c12);           // Буфер для умножения.

    cBigTemp c1; c1.checkexpand (n + 2);
    cBigTemp c2; c2.checkexpand (n + 4);
    cBigNumberCopyShr (p2, n, EXPTRTYPE(c2));   // Старшая часть p2 в c2.

//      Размер p1 может быть n или меньше если p1 вдвое или более короче p2.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения c2 при рекурсивном вызове.

    if (n1 > n)
    {
      cBigNumberCopyShr (p1, n, EXPTRTYPE(c1)); // Старшая часть p1 в c1.
      CBNL lp = p1 [n];                         // Сохранение затираемого
      p1 [n] = (CBNL)(n1 - n);                  // слова и запоминание размера.
      p12 [0] = 0;                              // Очистка буфера умножения.
      cBigNumberMAddMulShlKar (p1 + n, EXPTRTYPE(c2), 0, p12);
                                                // Умножение c1 * c2.
      cBigNumberMSubShl (p, p12, k + n * 2);    // Накопление c1 * c2.
      cBigNumberMAddShl (p, p12, k + n);        // Накопление c1 * c2.
      p1 [n] = lp;                              // Восстановление слова.
      p1 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p1 [0] = (CBNL)(n + (lp < 0));            // Младшая часть p1.
      cBigNumberMAddShl (EXPTRTYPE(c1), p1, 0); // Сложение c1 + p1.
    }
    else
      cBigNumberCopy (p1, EXPTRTYPE(c1));       // Копирование p1 в c1.

//      Размер p2 не может быть n или меньше.

    assert (n2 > n);
    {
      size_t nc2 = c2.length() + 1;             // Добавление старшего 0-слова.
      c2.item (0) = (CBNL) nc2;
      ((EXPTR(CBNL)) EXPTRTYPE(c2)) [nc2] = 0;

      CBNL lp = p2 [n + 1];                     // Сохранение слова.
      p2 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p2 [0] = (CBNL)(n + 1);                   // Младшая часть p2.
      cBigNumberMAddShl (EXPTRTYPE(c2), p2, 0); // Сложение c2 + p2.
      p2 [n + 1] = lp;                          // Восстановление слова.

      p2 [0] = (CBNL) n;                        // Удаление старшего 0-слова.
      p12 [0] = 0;                              // Очистка буфера результата.
      cBigNumberMAddMulShlKar (p1, p2, 0, p12); // Умножение p1 * p2.
      p2 [0] = (CBNL) n2;                       // Восстановление исходного p2.

      c2.item (0) = (CBNL)(c2.length() - (c2.hiword() == 0));
                                                // Удаление старшего 0-слова.
      cBigNumberCopy (CBPTRTYPE(c1), p1);       // Накопление (c1+p2)*(c2+p2).
      cBigNumberMSubMulShlKar (p1, EXPTRTYPE(c2), k + n, p);

      cBigNumberMAddShl (p, p12, k + n);        // Накопление p1 * p2.
      cBigNumberMSubShl (p, p12, k);            // Накопление p1 * p2.
    }

    return;
  }
#endif//_CBIGNUM_KARATSUBA_MUL

//      Умножение 1-го операнда по частям, если 2-ой операнд небольшой.
//
//      Старшая часть может быть положительной или отрицательной, но младшие
//      части всегда положительные, поэтому добавляем к ним старшее 0-слово.
//      Старшая и последующие части содержат _CBNL_TAB_OPT + 1 слов,
//      включая старшее 0-слово для всех частей кроме старшей, самая
//      младшая часть может содержать до _CBNL_TAB_HIGH слов вместе со
//      добавочным старшим 0-словом.
//
//      Алгоритм выделяет части без копирования.

#ifdef  _CBIGNUM_BLOCK_MUL
  if (n1 > _CBNL_TAB_HIGH)
  {                                             // Учет старшего слова
    --n1;                                       // старшей части.
    do                                          // Цикл по частям.
    {
      n1 -= _CBNL_TAB_OPT;                      // Размер всех младших частей.
      CBNL lp = p1 [n1];                        // Сохранение затираемого
      p1 [n1] = _CBNL_TAB_OPT + 1;              // слова и запоминание размера.
#ifdef  _CBIGNUM_SHIFTTAB_MUL
      if (n2 >= _CBNL_TAB_MIN) {                // Нужна таблица сдвигов?
        cBigNumberTab (p1 + n1);                // Подготовка таблицы сдвигов.
        cBigNumberMSubMulShlTab (p1 + n1, p2, k + n1, p);
      } else
#endif//_CBIGNUM_SHIFTTAB_MUL
        cBigNumberMSubMulShl (p1 + n1, p2, k + n1, p);
      p1 [n1 + 1] = 0;                          // Добавление старшего 0-слова.
      p1 [n1] = lp;                             // Восстановление слова.
    }
    while (n1 >= _CBNL_TAB_HIGH);
    p1 [0] = (CBNL)(n1 + 1);                    // Размер последней части.
  }
#endif//_CBIGNUM_BLOCK_MUL

//      Умножение последней части.

#ifdef  _CBIGNUM_SHIFTTAB_MUL
#ifdef  _CBIGNUM_BLOCK_MUL
  if (n2 >= _CBNL_TAB_MIN) {                    // Нужна таблица сдвигов?
#else
  if (n2 >= _CBNL_TAB_MIN && n1 <= _CBNL_TAB_HIGH) {
#endif//_CBIGNUM_BLOCK_MUL
    cBigNumberTab (p1);                         // Подготовка таблицы сдвигов.
    cBigNumberMSubMulShlTab (p1, p2, k, p);
  } else
#endif//_CBIGNUM_SHIFTTAB_MUL
    cBigNumberMSubMulShl (p1, p2, k, p);
}

//      Универсальные функции умножения работают с числами любых знаков.
//      Для ускорения умножения функции могут использовать метод Карацубы
//      и строить временные таблицы сдвигов.
//
//      Для лучшей производительности операнд существенно большего
//      размера рекомендуется поставить первым.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMul (                     // Умножение со сложением
                                                // p += p1 * p2.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Множитель.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + 1) + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand ((n2 < _CBNL_TAB_MIN)? (n1 + 2):
                        (n1 < _CBNL_TAB_HIGH)? ((n1 + 3) * BITS + 1):
                          (n1 + 2 + (_CBNL_TAB_HIGH + 2) * BITS + 1));
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Копирование множимого.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberMAddMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberMSubMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
}

void    cBigNumberMSubMul (                     // Умножение с вычитанием
                                                // p -= p1 * p2.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Множитель.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + 1) + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand ((n2 < _CBNL_TAB_MIN)? (n1 + 2):
                        (n1 < _CBNL_TAB_HIGH)? ((n1 + 3) * BITS + 1):
                          (n1 + 2 + (_CBNL_TAB_HIGH + 2) * BITS + 1));
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Копирование множимого.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberMSubMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberMAddMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
}

void    cBigNumberMul (                         // Умножение p = p1 * p2.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Множитель.
                        EXPTR(CBNL) p           // Буфер размера
                                                // *p1 + *p2 + 3.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand ((n2 < _CBNL_TAB_MIN)? (n1 + 2):
                        (n1 < _CBNL_TAB_HIGH)? ((n1 + 3) * BITS + 1):
                          (n1 + 2 + (_CBNL_TAB_HIGH + 2) * BITS + 1));
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Копирование множимого.

//      Обнуление результата - единственное различие между cBigNumberMul()
//      и cBigNumberMAddMul(). Результат можно обнулить после копирования
//      чисел, поскольку операнды могут перекрываться.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    p [0] = 0;                                  // Обнуление произведения.
    cBigNumberMAddMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    p [0] = 0;                                  // Обнуление произведения.
    cBigNumberMSubMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
}

//================================================
//      Реализация умножения в двойное слово без
//      применения аппаратной операции в Cbignumf,
//      для всем классе при отключении _CBNL_MUL.
//================================================

#ifndef NCHECKPTR
#ifdef  __cplusplus
extern "C" {
#endif//__cplusplus
#endif//NCHECKPTR

#undef  _muldCBNL
#define _muldCBNL   _muldCBNL_c
#undef  _umuldCBNL
#define _umuldCBNL  _umuldCBNL_c

//      Функция умножения чисел CBNL в двойное слово.
//      Вызывается как _muldCBNL

CBNL   _CBNL_C  _muldCBNL_c (                   // Умножение p = p1 * p2.
                        CBNL    l1,             // Множимое.
                        CBNL    l2,             // Множитель.
                        CBNL    *p              // Старшее слово результата.
        )                                       // Выдает младшее слово.
{
  CBNL c1 [5]; c1 [0] = 1; c1 [1] = l1;         // Буфер для множимого.
  CBNL c2 [3]; c2 [0] = 1; c2 [1] = l2;         // Буфер для множителя.
  CBNL c  [5]; c [0] = c [1] = c [2] = 0;       // Буфер для результата.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);
  EXPTR(CBNL) pp  = EXPTRTO(CBNL,c, sizeof(c) /sizeof(*c) -1);

  if (l2 >= 0)                                  // Множитель неотрицателен:
    cBigNumberMAddMulShl (pp1, pp2, 0, pp);     // Умножение.
  else {                                        // Множитель отрицателен:
    c2 [1] = -l2;                               // Смена знака.
    cBigNumberMSubMulShl (pp1, pp2, 0, pp);     // Умножение.
  }

  *p = c [2];                                   // Старшее слово.
  return c [1];                                 // Младшее слово.
}

//      Функция умножения беззнаковых чисел CBNL в двойное слово.
//      Вызывается как _umuldCBNL

unsigned
CBNL   _CBNL_C  _umuldCBNL_c (                  // Умножение l1 * l2.
                unsigned CBNL   l1,             // Беззнаковое множимое.
                unsigned CBNL   l2,             // Беззнаковый множитель.
                unsigned CBNL   *p              // Старшее слово результата.
        )                                       // Выдает младшее слово.
{                                               // Буфер для множимого.
  CBNL c1 [5]; c1 [0] = 2; c1 [1] = l1; c1 [2] = 0;
  CBNL c2 [3]; c2 [0] = 1; c2 [1] = l2;         // Буфер для множителя.
  CBNL c  [6]; c [0] = c [1] = c [2] = 0;       // Буфер для результата.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);
  EXPTR(CBNL) pp  = EXPTRTO(CBNL,c, sizeof(c) /sizeof(*c) -1);

  cBigNumberMAddMulShl (pp1, pp2, 0, pp);       // Умножение.

  *p = c [2];                                   // Старшее слово.
  return c [1];                                 // Младшее слово.
}

#ifndef NCHECKPTR
#ifdef  __cplusplus
}
#endif//__cplusplus
#endif//NCHECKPTR

#else //_CBIGNUM_HARDWARE_MUL

//================================================
//      Функции быстрого аппаратного умножения.
//================================================

#ifndef _CBIGNUM_ASM                            // Если не в Cbignumf.cpp

//      Специализированные функции сложения и вычитания с предварительным
//      умножением второго операнда на беззнаковый множитель типа CBNL и
//      сдвигом произведения влево на заданное число слов.
//
//      Множимое и множитель рассматриваются, как БЕЗЗНАКОВЫЕ числа,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Для целей оптимизации предполагается, что:
//      - Размер аккумулятора больше, чем размер множимого после
//        сдвига + дополнительное слово для реализации на С++
//        и не меньше, чем размер результата.
//      - Размер множимого до сдвига больше 0.
//
//      Функции не требуют нормализации операндов, более того, аккумулятор
//      должен быть предварительно денормализован до числа слов,
//      достаточного для хранения результата. Число слов в аккумуляторе
//      не меняется, поэтому результат может быть ненормализованным.

void   _CBNL_C  cBigNumberMAddMulM (            // Сложение p1+=p2*l2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Слагаемое, затем результат.
                const   CBPTR(CBNL) p2,         // Беззнаковое множимое.
                     unsigned CBNL  l2,         // Беззнаковый множитель.
                            size_t  k2          // Сдвиг произведения влево.
        )                                       // p1, p2 не могут совпадать.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  assert ((size_t)(*p1) > n2 + k2 + 1);         // Проверка размера.
  assert (n2 > 0);                              // Проверка размера.
  assert (p1 != p2);                            // Проверка несовпадения.

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

  cBigTemp c; c.checkexpand (n2 + 2);           // Выделение временного буфера
  EXPTR(CBNL) p = EXPTRTYPE(c);                 // для умножения.
  {
    size_t k = 1;
    do                                          // Цикл по нечетным словам p2.
      cULongMul (p2 [k], l2, (unsigned CBNL*)EXPTRINDEX(p + k, 1));
    while ((k += 2) <= n2);                     // Конец цикла по словам p2.
    p [k] = 0; p [0] = (CBNL) k;                // Ненулевое старшее слово -
    cBigNumberMAddM (p1, p, k2);                // знак для cBigNumberMAddM
  }                                             // при старшем бите 1.
  if (n2 > 1)
  {
    size_t k = 1;
    do                                          // Цикл по четным словам p2.
      cULongMul (p2 [k + 1], l2, (unsigned CBNL*)EXPTRINDEX(p + k, 1));
    while ((k += 2) < n2);                      // Конец цикла по словам p2.
    p [k] = 0; p [0] = (CBNL) k;                // Ненулевое старшее слово -
    cBigNumberMAddM (p1, p, k2 + 1);            // знак для cBigNumberMAddM
  }                                             // при старшем бите 1.
}

void   _CBNL_C  cBigNumberMSubMulM (            // Вычитание p1-=p2*l2<<k2*BITS
                        EXPTR(CBNL) p1,         // Вычитаемое, затем результат.
                const   CBPTR(CBNL) p2,         // Беззнаковое множимое.
                     unsigned CBNL  l2,         // Беззнаковый множитель.
                            size_t  k2          // Сдвиг произведения влево.
        )                                       // p1, p2 не могут совпадать.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  assert ((size_t)(*p1) > n2 + k2 + 1);         // Проверка размера.
  assert (n2 > 0);                              // Проверка размера.
  assert (p1 != p2);                            // Проверка несовпадения.

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

  cBigTemp c; c.checkexpand (n2 + 2);           // Выделение временного буфера
  EXPTR(CBNL) p = EXPTRTYPE(c);                 // для умножения.
  {
    size_t k = 1;
    do                                          // Цикл по нечетным словам p2.
      cULongMul (p2 [k], l2, (unsigned CBNL*)EXPTRINDEX(p + k, 1));
    while ((k += 2) <= n2);                     // Конец цикла по словам p2.
    p [k] = 0; p [0] = (CBNL) k;                // Ненулевое старшее слово -
    cBigNumberMSubM (p1, p, k2);                // знак для cBigNumberMSubM
  }                                             // при старшем бите 1.
  if (n2 > 1)
  {
    size_t k = 1;
    do                                          // Цикл по четным словам p2.
      cULongMul (p2 [k + 1], l2, (unsigned CBNL*)EXPTRINDEX(p + k, 1));
    while ((k += 2) < n2);                      // Конец цикла по словам p2.
    p [k] = 0; p [0] = (CBNL) k;                // Ненулевое старшее слово -
    cBigNumberMSubM (p1, p, k2 + 1);            // знак для cBigNumberMSubM
  }                                             // при старшем бите 1.
}

#endif//_CBIGNUM_ASM

//      Специализированные функции для аппаратного умножения со сдвигом и
//      и накоплением по школьному методу. Метод эффективен, если размер
//      хотя бы одного операнда не превосходит _CBNL_KARATSUBA_MIN * 4.
//      Для лучшей производительности операнд большего размера следует
//      поставить вторым, если только его размер не больше _CBNL_MUL_HIGH.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов, более того, аккумулятор
//      должен быть предварительно денормализован до числа слов,
//      достаточного для хранения результата. Число слов в аккумуляторе
//      не меняется, поэтому результат может быть ненормализованным.

void   _CBNL_C  cBigNumberMAddMulShlM (         // Умножение со сложением
                                                // p += p1 * p2 << k*BITS.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое размера
                                                // *p >= *p1 + *p2 + k + 1 -
                                                //           (p1 [*p1] == 0);
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм с аппаратным умножением.

  if (n1 != 0 && n2 != 0)                       // Операнды непустые?
  {
    CBNL lp1 = *p1++;                           // Первое слово p1.

    if (--n1 != 0)
    do                                          // Цикл по словам p1.
    {
      if (lp1 != 0) cBigNumberMAddMulM (p, p2, lp1, k);
      lp1 = *p1++; k++;                         // Следующее слово p1.
    }
    while (--n1 != 0);                          // Конец цикла по словам p1.

    if (lp1 > 0)                                // Проверка положительности.
      cBigNumberMAddMulM (p, p2, lp1, k);
    else if (lp1 < 0)                           // Проверка отрицательности.
      cBigNumberMSubMulM (p, p2, -lp1, k);
  }
}

void   _CBNL_C  cBigNumberMSubMulShlM (         // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое размера
                                                // *p >= *p1 + *p2 + k + 1 -
                                                //           (p1 [*p1] == 0);
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм с аппаратным умножением.

  if (n1 != 0 && n2 != 0)                       // Операнды непустые?
  {
    CBNL lp1 = *p1++;                           // Первое слово p1.

    if (--n1 != 0)
    do                                          // Цикл по словам p1.
    {
      if (lp1 != 0) cBigNumberMSubMulM (p, p2, lp1, k);
      lp1 = *p1++; k++;                         // Следующее слово p1.
    }
    while (--n1 != 0);                          // Конец цикла по словам p1.

    if (lp1 > 0)                                // Проверка положительности.
      cBigNumberMSubMulM (p, p2, lp1, k);
    else if (lp1 < 0)                           // Проверка отрицательности.
      cBigNumberMAddMulM (p, p2, -lp1, k);
  }
}

//      То же самое, но не требуется предварительная денормализация
//      аккумулятора и проводится нормализация результата.
//
//      ПРИМЕЧАНИЕ: Эти же функции реализуются через сдвиги,
//                  там буфер p1 перетирается, а также требуется, чтобы он
//                  был больше размера числа - см. комментарии выше.

void    cBigNumberMAddMulShl (                  // Умножение со сложением
                                                // p += p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое (**).
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1,p2,p не могут совпадать.
                                                // ** Буфер p1 не перетирается.
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigNumberFitTo (p, n1 + n2 + k + 1);         // Денормализация.
  cBigNumberMAddMulShlM (p1, p2, k, p);
  cBigNumberFit (p);                            // Нормализация.
}

void    cBigNumberMSubMulShl (                  // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое (**).
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1,p2,p не могут совпадать.
                                                // ** Буфер p1 не перетирается.
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigNumberFitTo (p, n1 + n2 + k + 1);         // Денормализация.
  cBigNumberMSubMulShlM (p1, p2, k, p);
  cBigNumberFit (p);                            // Нормализация.
}

//      Специализированные функции для аппаратного умножения со
//      сдвигом и накоплением по методу Карацубы.
//      Для лучшей производительности операнд существенно большего
//      размера рекомендуется поставить вторым.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов, более того, аккумулятор
//      должен быть предварительно денормализован до числа слов,
//      достаточного для хранения результата. Число слов в аккумуляторе
//      не меняется, поэтому результат может быть ненормализованным.

void   _CBNL_C  cBigNumberMAddMulShlKarM (      // Умножение со сложением
                                                // p += p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое.
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое размера
                                                // *p >= *p1 + *p2 + k + 2.
        )                                       // p1,p2,p не могут совпадать.
                                                // Изменяются только *p1, *p2.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
#ifdef  _CBIGNUM_KARATSUBA_MUL
  size_t n1 = (size_t)(*p1);                    // Число слов.
#endif//_CBIGNUM_KARATSUBA_MUL
  size_t n2 = (size_t)(*p2);                    // Число слов.

//      Проверка применимости метода Карацубы.

#ifdef  _CBIGNUM_KARATSUBA_MUL
  if (n1 > _CBNL_KARATSUBA_MIN && n2 > _CBNL_KARATSUBA_MIN)
  {

//      Умножение большого 2-го операнда по частям.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения кода p1 при рекурсивном
//                  вызове. Только *p1 может измениться.

    while (n2 > n1 * 2 - n1 / 4)                // Проверка размера.
    {
      CBNL lp = p2 [n2 -= n1];                  // Сохранение слова.
      p2 [n2] = (CBNL) n1;                      // Запоминание размера.
      cBigNumberMAddMulShlKarM (p1, p2 + n2, k + n2, p);
      p2 [n2] = lp;                             // Восстановление слова.
      p2 [0] = (CBNL) n2;                       // Размер последней части.
      p1 [0] = (CBNL) n1;                       // Восстановление размера p1.
    }

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

//      Умножение операндов близкого размера по методу Карацубы.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения кода p1 и p2 при рекурсивном
//                  вызове. Только *p1 и *p2 могут измениться.

    assert ((size_t)(*p) >= n1 + n2 + k);       // Проверка размера.
    size_t n = (n1 > n2? n1 - 1: n2) / 2;       // Размер младшей части.

//      Размер p1 не может быть n или меньше.
//      Размер p2 может быть n или меньше если p2 вдвое или более короче p1.
//      ПРИМЕЧАНИЕ: Чтобы не было переполнения p в редком специальном
//                  случае, когда p2 вдвое короче p1 или еще меньше,
//                  старшая часть p1 должна быть длиннее младшей части p1.

    cBigTemp c12; c12.checkexpand (n * 2 + 6);  // Выделение временного буфера.
    EXPTR(CBNL) p12 = EXPTRTYPE(c12);           // Указатель временного буфера.

//      Накопление старшей p1 * старшей p2, сохранение старшей p2 + младшей p2.
//      ПРИМЕЧАНИЕ: p1 и p2 не изменяются, за исключением *p2.

    assert (n1 > n);
    if (n2 > n)
    {
      CBNL lp1 = p1 [n];                        // Сохранение слова.
      CBNL lp2 = p2 [n];                        // Сохранение слова.
      p1 [n] = (CBNL)(n1 -= n);                 // Установка размера.
      p2 [n] = (CBNL)(n2 -= n);                 // Установка размера.
      cBigNumberClearTo (p12, n1 + n2 + 2);     // Очистка буфера умножения.
      cBigNumberMAddMulShlKarM (p1 + n, p2 + n, 0, p12);
                                                // Умножение старшей p1 * p2.
      --*EXPTRBASE(p12);                        // Частичная нормализация.
      cBigNumberMAddM (p, p12, k + n * 2);      // Накопление старшей p1 * p2.
      cBigNumberMSubM (p, p12, k + n);          // Накопление старшей p1 * p2.
      p1 [n] = lp1;                             // Восстановление слова.
      p2 [n] = lp2;                             // Восстановление слова.

      cBigNumberCopyShrUToM (p2, n, p12);       // Старшая часть p2.

      CBNL lp = p2 [n + 1];                     // Сохранение слова.
      p2 [n + 1] = 0;                           // Добавление старшего 0-слова.
      *EXPTRBASE(p2) = (CBNL)(n + 1);           // Младшая часть p2.
      cBigNumberMAddM (p12, p2, 0);             // Сложение старшей+младшей p2.
      *EXPTRBASE(p2) = (CBNL) n;                // Удаление старшего 0-слова.
      n2 = n;                                   // Размер младшей части.
      p2 [n + 1] = lp;                          // Восстановление слова.

      size_t n12 = (size_t)(*EXPTRBASE(p12));   // Число слов.
      while (p12 [n12] == 0 && --n12 != 0) continue;
      *EXPTRBASE(p12) = (CBNL) n12;             // Удаление старших 0-слов.
    }
    else
      cBigNumberCopy (p2, p12);                 // Копирование p2.

//      Накопление (старшей p1 + младшей p1) * (старшей p2 + младшей p2) и
//                  младшей p1 * младшей p2.
//      ПРИМЕЧАНИЕ: p1 и p2 не изменяются, за исключением *p1 и *p2.

    {
      cBigNumberCopyShrToM (p1, n, p12 + n + 3);// Старшая часть p1.
      CBNL lp = p1 [n + 1];                     // Сохранение слова.
      p1 [n + 1] = 0;                           // Добавление старшего 0-слова.
      *EXPTRBASE(p1) = (CBNL)(n + 1);           // Младшая часть p1.
      cBigNumberMAddM (p12 + n + 3, p1, 0);     // Сложение старшей+младшей p1.
      cBigNumberFit (p12 + n + 3);              // Нормализация.

      cBigNumberMAddMulShlKarM (p12 + n + 3, p12, k + n, p);
                                                // Накопление сумм p1 * p2.

      cBigNumberClearTo (p12, n + n2 + 3);      // Очистка буфера умножения.
      cBigNumberMAddMulShlKarM (p1, p2, 0, p12);// Умножение младшей p1 * p2.
      (*EXPTRBASE(p12)) -= 2;                   // Частичная нормализация.
      cBigNumberMSubM (p, p12, k + n);          // Накопление младшей p1 * p2.
      cBigNumberMAddM (p, p12, k);              // Накопление младшей p1 * p2.

      p1 [n + 1] = lp;                          // Восстановление слова.
    }

    return;
  }
#endif//_CBIGNUM_KARATSUBA_MUL

//      Умножение 2-го операнда по частям, если 1-ый операнд небольшой.
//
//      Старшая часть может быть положительной или отрицательной, но младшие
//      части всегда положительные, поэтому добавляем к ним старшее 0-слово.
//      Старшая и последующие части содержат _CBNL_MUL_OPT + 1 слов,
//      включая старшее 0-слово для всех частей кроме старшей, самая
//      младшая часть может содержать до _CBNL_MUL_HIGH слов вместе со
//      добавочным старшим 0-словом.
//
//      Алгоритм выделяет части без копирования.

#ifdef  _CBIGNUM_BLOCK_MUL
  if (n2 > _CBNL_MUL_HIGH)
  {
    do                                          // Цикл по частям.
    {
      n2 -= _CBNL_MUL_OPT + 1;                  // Размер всех младших частей.
      CBNL lp = p2 [n2];                        // Сохранение слова.
      p2 [n2] = _CBNL_MUL_OPT + 1;              // Установка размера части.
      cBigNumberMAddMulShlM (p1, p2 + n2, k + n2, p);
      p2 [n2] = lp;                             // Восстановление слова.
    }
    while (n2 >= _CBNL_MUL_HIGH);
    p2 [0] = (CBNL) n2;                         // Размер самой младшей части.
  }
#endif//_CBIGNUM_BLOCK_MUL

//      Умножение последней части.

  cBigNumberMAddMulShlM (p1, p2, k, p);
}

void   _CBNL_C  cBigNumberMSubMulShlKarM (     // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое.
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое размера
                                                // *p >= *p1 + *p2 + k + 2.
        )                                       // p1,p2,p не могут совпадать.
                                                // Изменяются только *p1, *p2.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
#ifdef  _CBIGNUM_KARATSUBA_MUL
  size_t n1 = (size_t)(*p1);                    // Число слов.
#endif//_CBIGNUM_KARATSUBA_MUL
  size_t n2 = (size_t)(*p2);                    // Число слов.

//      Проверка применимости метода Карацубы.

#ifdef  _CBIGNUM_KARATSUBA_MUL
  if (n1 > _CBNL_KARATSUBA_MIN && n2 > _CBNL_KARATSUBA_MIN)
  {

//      Умножение большого 2-го операнда по частям.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения кода p1 при рекурсивном
//                  вызове. Только *p1 может измениться.

    while (n2 > n1 * 2 - n1 / 4)                // Проверка размера.
    {
      CBNL lp = p2 [n2 -= n1];                  // Сохранение слова.
      p2 [n2] = (CBNL) n1;                      // Запоминание размера.
      cBigNumberMSubMulShlKarM (p1, p2 + n2, k + n2, p);
      p2 [n2] = lp;                             // Восстановление слова.
      p2 [0] = (CBNL) n2;                       // Размер последней части.
      p1 [0] = (CBNL) n1;                       // Восстановление размера p1.
    }

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

//      Умножение операндов близкого размера по методу Карацубы.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения кода p1 и p2 при рекурсивном
//                  вызове. Только *p1 и *p2 могут измениться.

    assert ((size_t)(*p) >= n1 + n2 + k);       // Проверка размера.
    size_t n = (n1 > n2? n1 - 1: n2) / 2;       // Размер младшей части.

//      Размер p1 не может быть n или меньше.
//      Размер p2 может быть n или меньше если p2 вдвое или более короче p1.
//      ПРИМЕЧАНИЕ: Чтобы не было переполнения p в редком специальном
//                  случае, когда p2 вдвое короче p1 или еще меньше,
//                  старшая часть p1 должна быть длиннее младшей части p1.

    cBigTemp c12; c12.checkexpand (n * 2 + 6);  // Выделение временного буфера.
    EXPTR(CBNL) p12 = EXPTRTYPE(c12);           // Указатель временного буфера.

//      Накопление старшей p1 * старшей p2, сохранение старшей p2 + младшей p2.
//      ПРИМЕЧАНИЕ: p1 и p2 не изменяются, за исключением *p2.

    assert (n1 > n);
    if (n2 > n)
    {
      CBNL lp1 = p1 [n];                        // Сохранение слова.
      CBNL lp2 = p2 [n];                        // Сохранение слова.
      p1 [n] = (CBNL)(n1 -= n);                 // Установка размера.
      p2 [n] = (CBNL)(n2 -= n);                 // Установка размера.
      cBigNumberClearTo (p12, n1 + n2 + 2);     // Очистка буфера умножения.
      cBigNumberMAddMulShlKarM (p1 + n, p2 + n, 0, p12);
                                                // Умножение старшей p1 * p2.
      --*EXPTRBASE(p12);                        // Частичная нормализация.
      cBigNumberMSubM (p, p12, k + n * 2);      // Накопление старшей p1 * p2.
      cBigNumberMAddM (p, p12, k + n);          // Накопление старшей p1 * p2.
      p1 [n] = lp1;                             // Восстановление слова.
      p2 [n] = lp2;                             // Восстановление слова.

      cBigNumberCopyShrUToM (p2, n, p12);       // Старшая часть p2.

      CBNL lp = p2 [n + 1];                     // Сохранение слова.
      p2 [n + 1] = 0;                           // Добавление старшего 0-слова.
      *EXPTRBASE(p2) = (CBNL)(n + 1);           // Младшая часть p2.
      cBigNumberMAddM (p12, p2, 0);             // Сложение старшей+младшей p2.
      *EXPTRBASE(p2) = (CBNL) n;                // Удаление старшего 0-слова.
      n2 = n;                                   // Размер младшей части.
      p2 [n + 1] = lp;                          // Восстановление слова.

      size_t n12 = (size_t)(*EXPTRBASE(p12));   // Число слов.
      while (p12 [n12] == 0 && --n12 != 0) continue;
      *EXPTRBASE(p12) = (CBNL) n12;             // Удаление старших 0-слов.
    }
    else
      cBigNumberCopy (p2, p12);                 // Копирование p2.

//      Накопление (старшей p1 + младшей p1) * (старшей p2 + младшей p2) и
//                  младшей p1 * младшей p2.
//      ПРИМЕЧАНИЕ: p1 и p2 не изменяются, за исключением *p1 и *p2.

    {
      cBigNumberCopyShrToM (p1, n, p12 + n + 3);// Старшая часть p1.
      CBNL lp = p1 [n + 1];                     // Сохранение слова.
      p1 [n + 1] = 0;                           // Добавление старшего 0-слова.
      *EXPTRBASE(p1) = (CBNL)(n + 1);           // Младшая часть p1.
      cBigNumberMAddM (p12 + n + 3, p1, 0);     // Сложение старшей+младшей p1.
      cBigNumberFit (p12 + n + 3);              // Нормализация.

      cBigNumberMSubMulShlKarM (p12 + n + 3, p12, k + n, p);
                                                // Накопление сумм p1 * p2.

      cBigNumberClearTo (p12, n + n2 + 3);      // Очистка буфера умножения.
      cBigNumberMAddMulShlKarM (p1, p2, 0, p12);// Умножение младшей p1 * p2.
      (*EXPTRBASE(p12)) -= 2;                   // Частичная нормализация.
      cBigNumberMAddM (p, p12, k + n);          // Накопление младшей p1 * p2.
      cBigNumberMSubM (p, p12, k);              // Накопление младшей p1 * p2.

      p1 [n + 1] = lp;                          // Восстановление слова.
    }

    return;
  }
#endif//_CBIGNUM_KARATSUBA_MUL

//      Умножение 2-го операнда по частям, если 1-ый операнд небольшой.
//
//      Старшая часть может быть положительной или отрицательной, но младшие
//      части всегда положительные, поэтому добавляем к ним старшее 0-слово.
//      Старшая и последующие части содержат _CBNL_MUL_OPT + 1 слов,
//      включая старшее 0-слово для всех частей кроме старшей, самая
//      младшая часть может содержать до _CBNL_MUL_HIGH слов вместе со
//      добавочным старшим 0-словом.
//
//      Алгоритм выделяет части без копирования.

#ifdef  _CBIGNUM_BLOCK_MUL
  if (n2 > _CBNL_MUL_HIGH)
  {
    do                                          // Цикл по частям.
    {
      n2 -= _CBNL_MUL_OPT + 1;                  // Размер всех младших частей.
      CBNL lp = p2 [n2];                        // Сохранение слова.
      p2 [n2] = _CBNL_MUL_OPT + 1;              // Установка размера части.
      cBigNumberMSubMulShlM (p1, p2 + n2, k + n2, p);
      p2 [n2] = lp;                             // Восстановление слова.
    }
    while (n2 >= _CBNL_MUL_HIGH);
    p2 [0] = (CBNL) n2;                         // Размер самой младшей части.
  }
#endif//_CBIGNUM_BLOCK_MUL

//      Умножение последней части.

  cBigNumberMSubMulShlM (p1, p2, k, p);
}

//      То же самое, но не требуется предварительная денормализация
//      аккумулятора и проводится нормализация результата.
//
//      ПРИМЕЧАНИЕ: Эти же функции реализуются в Cbignumf.inl через сдвиги,
//                  там операнд большего размера рекомендуется ставить
//                  первым, буфер p1 перетирается и требуется, чтобы он был
//                  больше размера числа - см. комментарии в Cbignumf.inl.

void    cBigNumberMAddMulShlKar (               // Умножение со сложением
                                                // p += p1 *p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое (**).
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k + 1)
                                                //                        + 2.
        )                                       // p1, p2 могут совпадать.
                                                // ** Меняются только *p1, *p2.

{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*p2);                    // Число слов.

  cBigNumberFitTo (p, n1 + n2 + k + 2);         // Денормализация.
  cBigNumberMAddMulShlKarM (p1, p2, k, p);
  cBigNumberFit (p);                            // Нормализация.
}

void    cBigNumberMSubMulShlKar (               // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое (**).
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k + 1)
                                                //                        + 2.
        )                                       // p1, p2 могут совпадать.
                                                // ** Меняются только *p1, *p2.
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*p2);                    // Число слов.

  cBigNumberFitTo (p, n1 + n2 + k + 2);         // Денормализация.
  cBigNumberMSubMulShlKarM (p1, p2, k, p);
  cBigNumberFit (p);                            // Нормализация.
}

//      Универсальные функции умножения для чисел любых знаков, реализованные
//      через быстрое аппаратное умножение, работают с числами любых знаков.
//      Для ускорения умножения функции могут использовать метод Карацубы.
//
//      Для лучшей производительности операнд существенно
//      большего размера рекомендуется поставить первым, здесь p2.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMul (                     // Умножение со сложением
                                                // p += p1 * p2.
                const   CBPTR(CBNL) p2,         // Множитель.
                const   CBPTR(CBNL) p1,         // Множимое.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + 1) + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand (n1);                    // Распределение памяти.
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

  cBigNumberFitTo (p, n1 + n2 + 2);             // Денормализация.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Копирование множимого.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberMAddMulShlKarM (pp1, pp2, k, p);  // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberMSubMulShlKarM (pp1, pp2, k, p);  // Оптимизированное умножение.
  }

  cBigNumberFit (p);                            // Нормализация.
}

void    cBigNumberMSubMul (                     // Умножение с вычитанием
                                                // p -= p1 * p2.
                const   CBPTR(CBNL) p2,         // Множитель.
                const   CBPTR(CBNL) p1,         // Множимое.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + 1) + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand (n1);                    // Распределение памяти.
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

  cBigNumberFitTo (p, n1 + n2 + 2);             // Денормализация.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Копирование множимого.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberMSubMulShlKarM (pp1, pp2, k, p);  // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberMAddMulShlKarM (pp1, pp2, k, p);  // Оптимизированное умножение.
  }

  cBigNumberFit (p);                            // Нормализация.
}

void    cBigNumberMul (                         // Умножение p = p1 * p2.
                const   CBPTR(CBNL) p2,         // Множитель.
                const   CBPTR(CBNL) p1,         // Множимое.
                        EXPTR(CBNL) p           // Буфер размера
                                                // *p1 + *p2 + 3.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand (n1);                    // Распределение памяти.
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Копирование множимого.

//      Обнуление результата - единственное различие между cBigNumberMul()
//      и cBigNumberMAddMul(). Результат можно обнулить после копирования
//      чисел, поскольку операнды могут перекрываться.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberClearTo (p, n1 + n2 + 2);         // Очистка буфера умножения.
    cBigNumberMAddMulShlKarM (pp1, pp2, k, p);  // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberClearTo (p, n1 + n2 + 2);         // Очистка буфера умножения.
    cBigNumberMSubMulShlKarM (pp1, pp2, k, p);  // Оптимизированное умножение.
  }

  cBigNumberFit (p);                            // Нормализация.
}

#endif//_CBIGNUM_HARDWARE_MUL

//================================================
//      Функция, обрабатывающая деление на 0.
//================================================

void    cBigNumberDiv0()                        // Деление на 0.
{
  cBigNumberMaskDiv0 /= cBigNumberMaskDiv0;
}

//================================================
//      Функции целочисленного деления.
//================================================

//      Специализированная функция деления с таблицей сдвигов.
//      Предполагается, что делимое и делитель имеют одинаковый знак,
//      за исключением случая деления отрицательного числа на 0.
//      В буфере делителя должна находиться таблица сдвигов,
//      полученная функцией cBigNumberTab.
//
//      Функция определяет частное и заносит остаток на место делимого.
//      Частное >= 0. Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, частное равно 0,
//      остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованные частное и остаток.

void    cBigNumberMModDivShlTab (               // Деление
                                                // p = p1 / p2 << k2*BITS,
                                                //    p1 %= p2 << k2*BITS.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель и таблица сдвигов.
                        size_t      k2,         // Сдвиг делителя влево.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  size_t n = n2 + k2;                           // Число слов после сдвига.
  if (n > n1) n = n1;                           // Делимое короче делителя.
  n = n1 - n + 1;                               // Число слов в частном.

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

  *p = (CBNL)(n + 1); p += n; p [1] = 0;        // Начало заполнения p.
  n += k2;                                      // Сдвиг делителя.

//      Строим значащие слова частного в процессе вычисления остатка.

  if (n2 >= cBigNumberSkipLow0 (p2))            // Пропуск младших 0-слов и
  {                                             // проверка деления на 0.
    CBNL p2h = p2 [n2];                         // Старшее слово делителя.
    assert ((p1 [n1] ^ p2h) >= 0);              // Совпадение знаков.
    CBNL lt = (p2h < 0) * 2 - 1;                // Константа для сравнения
                                                // абсолютных значений чисел.
                                                // (p1 и p2 >= 0)? -1: 1
    p2h ^= (p2h >> (BITS-1));                   // Инверсия при p2 < 0.
    size_t nn2 = n + n2;                        // Размер сдвинутого делителя
    p2h = ((CBNL)1) << (_ulzcntCBNL(p2h) - 1);  // и маска его уменьшения на 1.
    n2 += 2;                                    // Шаг по таблице сдвигов.

    do                                          // Цикл по словам частного.
    {
      p2 += n2 * BITS; --n;                     // Подготовка цикла по битам.
      *p = 0;                                   // Обнуление слова частного.
      unsigned CBNL mask = ((unsigned CBNL)1) << (BITS-1);
                                                // Начальная маска.
      do                                        // Цикл по битам частного.
      {                                         // Вычисление разности размеров
        p2 -= n2;                               // после сдвига делителя на бит.
        CBNL diff = nn2 - ((unsigned CBNL)p2h >= mask) - n1;
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, p2, n) != lt)) // сдвинутого делителя,
        {                                       // то вычитаем делитель.
          assert (diff < 0 ? p1 [n1] == p2 [(size_t)(*p2) + 1] : 1);
          // Предусловие вызова _cBigNumberMSubD() в альтернативном варианте.
          // В случае различных размеров делитель должен иметь резервное
          // слово расширения знака, аналогичное старшему слову делимого.
          // Резервное слово формируется cBigNumberTab() для сдвигов в
          // начале таблицы до увеличения размера на 1, далее не требуется.
          n1 = _cBigNumberMSubD (p1, p2, n);    // Вычитание делителя.
          p1 [0] = (CBNL) n1;                   // Запоминание размера.
          (*p) += mask;                         // Установка бита частного.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
      --p; --nn2;                               // Слово частного сформировано.
    }
    while (n > k2);                             // Конец цикла по словам.

    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, p2) == lt);     // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
    do { *p-- = 0; } while (--n);               // будет равен делимому
  }                                             // и частное равно 0.

  cBigNumberFit (p);                            // Нормализация частного.
  assert (p [(size_t)(*p)] >= 0);               // Проверка неотрицательности.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

#ifdef  _CBNL_TAB_FULL

//      Специализированная функция деления с половинной таблицей сдвигов.
//
//      Метод использует сдвинутый на полслова дополнительный код чисел из
//      первой половины таблицы сдвигов вместо второй половинной таблицы.
//
//      Сдвинутый код не содержит правильно расположенное слово с длиной,
//      поэтому надо вычислять длину сдвинутого делителя вместо чтения.
//      Поскольку чтение невыровненных слов работает медленнее, чем для
//      выровненных слов, то этот метод только для экономии памяти.

void    cBigNumberMModDivShlTab2 (              // Деление
                                                // p = p1 / p2 << k2*BITS,
                                                //    p1 %= p2 << k2*BITS.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель и таблица сдвигов.
                        size_t      k2,         // Сдвиг делителя влево.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  size_t n = n2 + k2;                           // Число слов после сдвига.
  if (n > n1) n = n1;                           // Делимое короче делителя.
  n = n1 - n + 1;                               // Число слов в частном.

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

  *p = (CBNL)(n + 1); p += n; p [1] = 0;        // Начало заполнения p.
  n += k2;                                      // Сдвиг делителя.

//      Строим значащие слова частного в процессе вычисления остатка.

  if (n2 >= cBigNumberSkipLow0 (p2))            // Пропуск младших 0-слов и
  {                                             // проверка деления на 0.
    CBNL p2h = p2 [n2];                         // Старшее слово делителя.
    assert ((p1 [n1] ^ p2h) >= 0);              // Совпадение знаков.
    CBNL lt = (p2h < 0) * 2 - 1;                // Константа для сравнения
                                                // абсолютных значений чисел.
                                                // (p1 и p2 >= 0)? -1: 1
    p2h ^= (p2h >> (BITS-1));                   // Инверсия при p2 < 0.
    size_t nn2 = n + n2;                        // Размер сдвинутого делителя
    p2h = ((CBNL)1) << (_ulzcntCBNL(p2h) - 1);  // и маска его уменьшения на 1.
    n2 += 2;                                    // Шаг по таблице сдвигов.
    p2 += n2 * BITS/2;                          // Конец таблицы сдвигов.

    do                                          // Цикл по словам частного.
    {
      const CBNL* pp2 = (const CBNL*)           // Сдвинутый на полслова p2.
                        ((const int*)(CBPTRBASE(p2)) - 1);
      --n;                                      // Сдвиг pp2.
      *p = 0;                                   // Обнуление слова частного.
      unsigned CBNL mask = ((unsigned CBNL)1) << (BITS-1);
                                                // Начальная маска.
      do                                        // Цикл по старшим сдвигам.
      {                                         // Вычисление разности размеров
        pp2 -= n2;                              // после сдвига делителя на бит.
        CBNL diff = nn2 - ((unsigned CBNL)p2h >= mask) - n1;
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, pp2, n) != lt))// сдвинутого делителя,
        {                                       // то вычитаем делитель.
          n1 = _cBigNumberMSubD (p1, pp2, n);   // Вычитание делителя.
          p1 [0] = (CBNL) n1;                   // Запоминание размера.
          (*p) += mask;                         // Установка бита частного.
        }
      }
      while ((unsigned)(mask >>= 1) == 0);      // Конец цикла по сдвигам.

      pp2 = CBPTRBASE(p2);                      // Не сдвинутый p2.
      do                                        // Цикл по старшим сдвигам.
      {                                         // Вычисление разности размеров
        pp2 -= n2;                              // после сдвига делителя на бит.
        CBNL diff = nn2 - ((unsigned CBNL)p2h >= mask) - n1;
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, pp2, n) != lt))// сдвинутого делителя,
        {                                       // то вычитаем делитель.
          assert (diff < 0 ? p1 [n1] == pp2 [(size_t)(*pp2) + 1] : 1);
          // Предусловие вызова _cBigNumberMSubD() в альтернативном варианте.
          // В случае различных размеров делитель должен иметь резервное
          // слово расширения знака, аналогичное старшему слову делимого.
          // Резервное слово формируется cBigNumberTab() для сдвигов в
          // начале таблицы до увеличения размера на 1, далее не требуется.
          n1 = _cBigNumberMSubD (p1, pp2, n);   // Вычитание делителя.
          p1 [0] = (CBNL) n1;                   // Запоминание размера.
          (*p) += mask;                         // Установка бита частного.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по сдвигам.
      --p; --nn2;                               // Слово частного сформировано.
    }
    while (n > k2);                             // Конец цикла по словам.

    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, p2) == lt);     // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
    do { *p-- = 0; } while (--n);               // будет равен делимому
  }                                             // и частное равно 0.

  cBigNumberFit (p);                            // Нормализация частного.
  assert (p [(size_t)(*p)] >= 0);               // Проверка неотрицательности.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

#endif//_CBNL_TAB_FULL

#if !defined(_CBIGNUM_HARDWARE_DIV) || !defined(_CBNL_DIV)

//================================================
//      Реализация деления двойного слова
//      через аддитивные операции в Cbignumf,
//      для всего класса при отключении _CBNL_DIV.
//================================================

#ifndef NCHECKPTR
#ifdef  __cplusplus
extern "C" {
#endif//__cplusplus
#endif//NCHECKPTR

#undef  _divdCBNL
#define _divdCBNL   _divdCBNL_c
#undef  _udivdCBNL
#define _udivdCBNL  _udivdCBNL_c

//      Деление двойного слова CBNL на одинарное слово с однословным частным.
//      При переполнении частного или делении на 0, если ошибки деления
//      разрешены, частное равно 0 и остаток равен младшему слову делимого.
//
//      Две реализации через неограниченное и оптимизированное деление.

#ifndef _CBNL_SMALL_DIV

//      Реализация через деление неограниченных чисел, менее эффективная.
//      Установка _CBIGNUM_SMALL_DIV исключает рекурсию _CBIGNUM_SUBMUL_DIV
//      и рекомендуется для увеличения производительности.

#ifdef  _CBIGNUM_SUBMUL_DIV
#if !defined(_CBIGNUM_SMALL_DIV) || _CBIGNUM_SMALL_DIV < 2
#undef  _CBIGNUM_SMALL_DIV
#define _CBIGNUM_SMALL_DIV 2
#endif//_CBIGNUM_SMALL_DIV
#endif//_CBIGNUM_SUBMUL_DIV

//      Функция деления двойного слова.
//      Вызывается как _divdCBNL

CBNL   _CBNL_C  _divdCBNL_c (                   // Деление ll,lh /% l2.
                        CBNL    ll,             // Младшее слово делимого.
                        CBNL    lh,             // Старшее слово делимого.
                        CBNL    l2,             // Делитель.
                        CBNL    *p              // Остаток.
        )                                       // Выдает частное.
{                                               // Буфер для делимого
  CBNL c1 [5]; c1 [0] = 2; c1 [1] = ll; c1 [2] = lh;    // и остатка.
  CBNL c2 [3]; c2 [0] = 1; c2 [1] = l2;         // Буфер для делителя.
  CBNL c  [5];                                  // Буфер для частного.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);
  EXPTR(CBNL) pp  = EXPTRTO(CBNL,c, sizeof(c) /sizeof(*c) -1);

  cBigNumberFit (pp1);                          // Нормализация.
  cBigNumberMModDiv (pp1, pp2, pp);             // Деление.
  if (c [0] > 1) { cBigNumberDiv0(); *p = ll; return 0; }
                                                // Проверка переполнения.
  *p = c1 [1];                                  // Остаток.
  return c [1];                                 // Частное.
}

//      Функция деления беззнакового двойного слова.
//      Вызывается как _udivdCBNL

unsigned
CBNL   _CBNL_C  _udivdCBNL_c (                  // Деление ll,lh /% l2.
                unsigned CBNL   ll,             // Младшее слово делимого.
                unsigned CBNL   lh,             // Старшее слово делимого.
                unsigned CBNL   l2,             // Беззнаковый делитель.
                unsigned CBNL   *p              // Беззнаковый остаток.
        )                                       // Выдает беззнаковое частное.
{                                               // Буфер для делимого и
  CBNL c1 [5]; c1 [0] = 3; c1 [1] = ll; c1 [2] = lh; c1 [3] = 0; // остатка.
  CBNL c2 [4]; c2 [0] = 2; c2 [1] = l2; c2 [2] = 0; // Буфер для делителя.
  CBNL c  [6];                                      // Буфер для частного.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);
  EXPTR(CBNL) pp  = EXPTRTO(CBNL,c, sizeof(c) /sizeof(*c) -1);

  cBigNumberFit (pp1);                          // Нормализация.
  cBigNumberMModDiv (pp1, pp2, pp);             // Деление.
  if (c [0] > 1 && c [2] != 0) { cBigNumberDiv0(); *p = ll; return 0; }
                                                // Проверка переполнения.
  *p = c1 [1];                                  // Остаток.
  return c [1];                                 // Частное.
}

#else //_CBNL_SMALL_DIV

//      Оптимизированная функция деления беззнакового двойного слова.
//      Call as _udivdCBNL

unsigned
CBNL   _CBNL_C  _udivdCBNL_c (                  // Деление ll,lh /% l2.
                unsigned CBNL   p1l,            // Младшее слово делимого.
                unsigned CBNL   p1h,            // Старшее слово делимого.
                unsigned CBNL   p2h,            // Беззнаковый делитель.
                unsigned CBNL   *p              // Беззнаковый остаток.
        )                                       // Выдает беззнаковое частное.
{
  unsigned CBNL pn = 0;                         // Частное.

//      Беззнаковый делитель может задействовать все биты слова CBNL,
//      что требует специальной обработки. Сначала упрощаем алгоритмы
//      проверкой переполнения и деления на 0.

  if (p1h < p2h)                                // Проверка ошибки деления.
  {
    unsigned CBNL mask = (unsigned CBNL)1;      // Маска для частного.

//      Деление двойного слова на одинарное с одинарным частным.

    if (p1h != 0)                               // Двухсловный делитель,
    {                                           // однословное делимое.
      CBNC nb = (int)_ulzcntCBNL (p1h) - (int)_ulzcntCBNL (p2h);
      assert (nb >= 0);                         // Разница в значащих битах.

//      Добавляем сдвиг делимого при одинаковом числе значащих бит, т.к.
//      p1h < p2h и запоминаем старший бит если делитель занимает все слово.

      unsigned CBNL pnc = (nb == 0? p2h: 0);    // Запоминание старшего бита.
      nb += (nb == 0);                          // Добавочный сдвиг.
      mask <<= BITS - nb;                       // Начальная маска частного.
      p1h = _ushldCBNL (p1l, p1h, nb);          // Выравнивание делимого.
      p1l = _ushlCBNL (p1l, nb);

//      Алгоритм с дополнительными битом остатка для делителя во все слово.

      if ((CBNL)p2h < 0)                        // Делитель во все слово.
      for (;;)                                  // Цикл по битам частного.
      {
        unsigned CBNL pnh = p1h - p2h;          // Если остаток с дополни-
        pnc |= (p1h >= p2h? p2h: 0);            // тельным битом не меньше,
        if ((CBNL)pnc < 0) p1h = pnh;           // то вычитание делителя и
        pn += ((CBNL)pnc < 0)? mask: 0;         // установка бита частного.
        if (!(mask >>= 1)) break;               // Биты закончились.
        pnc = p1h;                              // Запоминание старшего бита.
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l += p1l;
      }                                         // Конец цикла по битам.

//      Алгоритм для более короткого делителя с оптимизированным
//      сравнением путем вычитания (не для общего случая).

      else                                      // Более короткий делитель.
      for (;;)                                  // Цикл по битам частного.
      {
        unsigned CBNL pnh = p1h - p2h;          // Если остаток не меньше,
        if ((CBNL)pnh >= 0) p1h = pnh;          // то вычитание делителя и
        pn += ((CBNL)pnh >= 0)? mask: 0;        // установка бита частного.
        if (!(mask >>= 1)) break;               // Биты закончились.
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l += p1l;
      }                                         // Конец цикла по битам.
    }

//      Одинарное деление без применения аппаратной операции.

    else if ((p1h = p1l) >= p2h)                // Однословный делитель,
    {                                           // однословное делимое.
      CBNC nb = (int)_ulzcntCBNL (p2h) - (int)_ulzcntCBNL (p1h);
      assert (nb >= 0);                         // Разница в значащих битах.
      mask <<= nb;                              // Начальная маска частного.
      p2h <<= nb;                               // Выравнивание делителя.

//      Алгоритм с оптимизированным сравнением путем вычитания для делимого
//      и делителя во все слово или более короткого делителя. Для выполнения
//      этого требования мы убедились, что делимое не меньше делителя.

      for (;;)                                  // Цикл по битам частного.
      {
        unsigned CBNL pnh = p1h - p2h;          // Если остаток не меньше,
        if ((CBNL)pnh >= 0) p1h = pnh;          // то вычитание делителя и
        pn += ((CBNL)pnh >= 0)? mask: 0;        // установка бита частного.
        if (!(mask >>= 1)) break;               // Биты закончились.
        p2h >>= 1;                              // Сдвиг делителя вправо.
      }                                         // Конец цикла по битам.
    }
    assert (p1h < p2h);                         // Проверка остатка.
  }
  else { p1h = p1l; cBigNumberDiv0(); }         // Деление на 0
                                                // или переполнение.
  *p = p1h;                                     // Остаток.
  return pn;                                    // Частное.
}

//      Оптимизированная функция деления двойного слова.
//      Call as _divdCBNL

CBNL   _CBNL_C  _divdCBNL_c (                   // Деление ll,lh /% l2.
                        CBNL    p1l,            // Младшее слово делимого.
                        CBNL    p1h,            // Старшее слово делимого.
                        CBNL    p2h,            // Делитель.
                        CBNL    *p              // Остаток.
        )                                       // Выдает частное.
{
  CBNL signquot = p1h ^ p2h;                    // Знак частного.
  CBNL signrem = p1h;                           // Знак делимого/остатка.

  if (p1h < 0) p1h = ~p1h + ((p1l = -p1l) == 0);// Неотрицательное делимое.
  if (p2h < 0) p2h = -p2h;                      // Неотрицательный делитель.
  CBNL pn = (CBNL)_udivdCBNL (p1l, p1h, p2h, (unsigned CBNL *)p);
  if (signrem < 0) *p = -*p;                    // Установка знака остатка.
  if (signquot < 0) pn = -pn;                   // Установка знака частного.
  if ((pn ^ signquot) < 0 && pn)                // Проверка переполнения.
    cBigNumberDiv0();

  return pn;                                    // Частное.
}

#endif//_CBNL_SMALL_DIV

#ifndef NCHECKPTR
#ifdef  __cplusplus
}
#endif//__cplusplus
#endif//NCHECKPTR

#endif//_CBIGNUM_HARDWARE_DIV || _CBNL_DIV

//      Универсальная функция деления работает с числами любых знаков и
//      не требует наличия предварительно подготовленной таблицы сдвигов.
//      Если это ускоряет операцию, то функция сама строит временную таблицу
//      сдвигов, иначе применяет алгоритм, не использующий таблицу сдвигов.
//
//      Функция определяет частное и заносит остаток на место делимого.
//      Знак частного - это произведение знаков делимого и делителя.
//      Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, частное равно 0 и
//      остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованные частное и остаток.

void    cBigNumberMModDiv (                     // Деление p = p1 / p2,
                                                //         p1 %= p2.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток
                                                // в буфере размера *p1 + 3 -
                const   CBPTR(CBNL) p2,         // Делитель. (p1 [*p1] == 0);
                        EXPTR(CBNL) p           // Буфер размера *p1 + 3.
        )                                       // p2 может совпадать с p1, p.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Выделяем младшее и старшее слово делителя, если он короткий,
//      т.е. длины больше 0, но не больше _CBIGNUM_SMALL_DIV.

#ifdef  _CBIGNUM_SMALL_DIV
  unsigned CBNL p2h = 0, p2l = 0;               // Слова делителя или 0.
  if (n2 - 1 <= _CBIGNUM_SMALL_DIV - 1) { p2l = p2 [1];
                                          p2h = p2 [n2]; }

//      Выбираем общие алгоритмы для многословного делителя или
//      оптимизированные алгоритмы для ненулевого делителя,
//      содержащего не более _CBIGNUM_SMALL_DIV слов.

  if ((p2h | p2l) == 0)                         // Общий случай деления для
  {                                             // для многословного делителя.
#endif//_CBIGNUM_SMALL_DIV
    cBigTemp cBigBuf2;                          // Выделение временного буфера.
#ifdef _CBIGNUM_SUBMUL_DIV
    cBigBuf2.checkexpand ((size_t)(n2 + 2));
#else //_CBIGNUM_SUBMUL_DIV
#ifdef  _CBIGNUM_SHIFTTAB_DIV
    CBNL nt = (CBNL)((n2 - n1 + _CBNL_TAB_MIN - 1) & (n2 - _CBNL_TAB_MAX));
    cBigBuf2.checkexpand ((size_t)((nt >= 0)? (n2 + 3):
#ifdef  _CBNL_TAB_FULL
                       (n2 > _CBNL_TAB_FULL)? (n2 + 3) * BITS/2 + 1:
#endif//_CBNL_TAB_FULL
                                              (n2 + 3) * BITS + 1));
#else //_CBIGNUM_SHIFTTAB_DIV
    cBigBuf2.checkexpand ((size_t)(n2 + 3));
#endif//_CBIGNUM_SHIFTTAB_DIV
#endif//_CBIGNUM_SUBMUL_DIV
    EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);      // Буфер для делителя.

//      Копирование и нормализация ненулевого делителя с пропуском младших 0-слов.
//      Если делитель 0, то результат содержит 0 слов.

    size_t k2 = cBigNumberCopySkipLow0 (p2, pp2);

//      Определяем знак частного.
//      CBPTRBASE учитывает случай денормализованного нуля в p2.

    CBNL signquot = p1 [n1] ^ CBPTRBASE(p2)[n2];

#ifndef _CBIGNUM_SUBMUL_DIV

//      Обеспечиваем совпадение знаков делимого и делителя.

    if (signquot < 0) cBigNumberNeg (pp2, pp2); // Смена знака делителя.

//      Общий алгоритм с таблицей сдвигов.

#ifdef  _CBIGNUM_SHIFTTAB_DIV
    if (nt < 0)
    {
//      Выбираем экономящий память метод с половинной таблицей сдвигов
//      или метод с полной таблицей.
#ifdef  _CBNL_TAB_FULL
      if (n2 > _CBNL_TAB_FULL)
      {
        _cBigNumberTab (pp2, BITS/2);           // Подготовка таблицы сдвигов.
        cBigNumberMModDivShlTab2 (p1, pp2, k2, p);
      }                                         // Деление.
      else
#endif//_CBNL_TAB_FULL
      {
        cBigNumberTab (pp2);                    // Подготовка таблицы сдвигов.
        cBigNumberMModDivShlTab (p1, pp2, k2, p);
      }                                         // Деление.
      if (signquot < 0) cBigNumberNeg (p, p);   // Смена знака частного.
      return;
    }
#endif//_CBIGNUM_SHIFTTAB_DIV

//      Общий алгоритм, не применяющий таблицу сдвигов.

    n2 = (size_t)(*pp2);                        // Число слов.
    if (n2 == 0)                                // Делитель 0.
    {                                           // Если деление на 0
      cBigNumberDiv0();                         // разрешено, то остаток
      p [0] = 1; p [1] = 0;                     // будет равен делимому
      return;                                   // и частное равно 0.
    }
    assert (cBigNumberIsFit (pp2));             // Проверка нормализованности.

    size_t n = n2 + k2;                         // Число слов после сдвига.
    if (n <= n1) {
      n = n1 - n + 1;                           // Число слов в частном.
    } else {                                    // Если делимое короче
      p [0] = 1; p [1] = 0;                     // делителя, то остаток
      return;                                   // будет равен делимому
    }                                           // и частное равно 0.

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

    *p = (CBNL)(n + 1); p += n; p [1] = 0;      // Начало заполнения p.
    n += k2;                                    // Сдвиг делителя.

//      Строим значащие слова частного в процессе вычисления остатка.

    assert ((p1 [n1] ^ pp2 [n2]) >= 0);         // Проверка совпадения знаков.
    CBNL lt = (pp2 [n2] < 0) * 2 - 1;           // Константа для сравнения
                                                // абсолютных значений чисел
                                                // (p1 и pp2 >= 0)? -1: 1
    do                                          // Цикл по словам частного.
    {
      cBigNumberMShlD (pp2); --n;               // Сдвиг кода делителя на слово.
      *p = 0;                                   // Обнуление слова частного.
      unsigned CBNL mask = ((unsigned CBNL)1) << (BITS-1);
                                                // Начальная маска.
      do                                        // Цикл по битам частного.
      {
        CBNL diff = (CBNL)cBigNumberMDiv2D (pp2)// Сдвиг делителя на бит.
                  + (CBNL)n - (CBNL)n1;         // Разность размеров.
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, pp2, n) != lt))// сдвинутого делителя,
        {                                       // то вычитаем делитель.
          n1 = cBigNumberMSubD (p1, pp2, n);    // Вычитание делителя.
          (*p) += mask;                         // Установка бита частного.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
      --p;                                      // Слово частного сформировано.
    }
    while (n > k2);                             // Конец цикла по словам.

    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.

#else //_CBIGNUM_SUBMUL_DIV

//      Новый алгоритм с умножением.

    #undef  CPRG
    #define CPRG(a)

    n2 = (size_t)(*pp2);                        // Число слов.
    if (n2 == 0)                                // Делитель 0.
    {                                           // Если деление на 0
      cBigNumberDiv0();                         // разрешено, то остаток
      p [0] = 1; p [1] = 0;                     // будет равен делимому
      return;                                   // и частное равно 0.
    }
    assert (cBigNumberIsFit (pp2));             // Проверка нормализованности.

//      Делаем делитель положительным и беззнаковым.

    unsigned CBNL p2p = pp2 [n2];               // Старшее слово делителя.
    if ((CBNL)p2p < 0) {
      n2 = cBigNumberNeg (pp2, pp2);            // Смена знака делителя
      p2p = pp2 [n2];                           // и новое старшее слово.
    }
    void _CBNL_C (*pfNumberMSubM)(EXPTR(CBNL), const CBPTR(CBNL), size_t);
    if (p2p != 0) {                             // Исключение старшего 0-слова
      pfNumberMSubM = cBigNumberMSubM;          // и выбор специальной функции
    } else {                                    // для беззнакового вычитания.
      pfNumberMSubM = cBigNumberMSubMM; p2p = pp2 [--n2]; *pp2 = (CBNL)n2;
    }
    assert (pp2 [n2] != 0 && n2 > 0);

//      Проверяем, что делимое не короче делителя.

    CBNL signrem = p1 [n1];                     // Знак делимого/остатка.
    if (n1) n1 -= (signrem == 0);               // Не считаем старшее 0-слово.
    size_t n = n2 + k2;                         // Число слов после сдвига.
    if (n <= n1) {
      n = n1 - n + 1;                           // Число слов в частном.
    } else {                                    // Если делимое короче
      p [0] = 1; p [1] = 0;                     // делителя, то остаток
      return;                                   // будет равен делимому
    }                                           // и частное равно 0.
    assert (p1 [n1] != 0 && n1 > 0);

//      Готовим денормализованное частное с одним дополнительным словом
//      для знака. Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

    *p = 0; cBigNumberFitTo (p, n + 1);         // Начало заполнения p.
    CBNL pa [3] = { 2, 0, 0 };                  // Слагаемое для частного.

//      Делаем делимое положительным (старшее слово может стать нулевым).

    if (signrem < 0) {
      cBigNumberNeg (p1, p1);                   // Смена знака делимого.
    }

//      Дополнительные нулевые слова в остатке будут удалены при
//      его нормализации. Они нужны для cBigNumberMSubMulM.

    *p1 = n1 + 2; p1 [n1 + 2] = p1 [n1 + 1] = 0;

//      Выбираем алгоритм для многословного или однословного делителя.

    if (n2 > 1)                                 // Многословный делитель.
    {
      CBNC nb2 = (CBNC)_ulzcntCBNL (p2p);       // Число старших 0-битов.

//      Сдвигаем старшее слово делителя влево и добавляем 1 для оценки
//      младших слов. p2p может стать нулевым.

      p2p = _ushldCBNL (pp2 [n2 - 1], p2p, nb2) + 1;

//      Строим значащие слова частного в процессе вычисления остатка.

      n2 = n1 - n2; assert (n2 >= k2);          // Сдвиг делителя (слова).
      unsigned CBNL p1l = p1 [n1 - 1];          // Старшее слово делимого,
      unsigned CBNL p1h = p1 [n1];              // затем вычисленный множитель
                                                // для делителя.
//      Предварительное деление.

      CBNC nb1 = (CBNC)_ulzcntCBNL (p1h);       // Число старших 0-битов
      if (nb1 < nb2) {                          // меньше в делимом.
        assert (nb2 > 0);
        p1l = _ushrdCBNL (p1l, p1h, BITS - nb2);// Сдвиг делимого вправо и
        p1h = _ushrCBNL (p1h, BITS - nb2);      // деление старших слов дает
                                                // множитель для делителя.
        if (p2p) p1h = _udivdCBNL (p1l, p1h, p2p, (unsigned CBNL *)pa + 1);
        CPRG('\n'); CPRG((CBNL)n1); CPRG(' '); CPRG((CBNL)n2);
        CPRG(' '); CPRG((CBNL)nb1); CPRG(' '); CPRG((CBNL)nb2);
        CPRG(' '); CPRG((CBNL)p1h);
        p [n2 - k2 + 1] = p1h;                  // Старшее слово частного.
        cBigNumberMSubMulM (p1, pp2, p1h, n2);  // Уменьшение остатка.
        p1l = p1 [n1 - 1]; p1h = p1 [n1];       // Старшие слова остатка.
      }

//      Основной цикл деления сохраняет старшее слово частного максимум на
//      на бит длиннее старшего слова делителя, чтобы не было избыточных
//      вычитаний делителя. На каждой итерации цикла накапливается частное.

      for (;; p1l = p1 [n1 - 1], p1h = p1 [n1]) // Основной цикл деления для
      {                                         // старших слов частного.
        nb1 = (CBNC)_ulzcntCBNL (p1h);          // Число старших 0-битов.
        CPRG('\n'); CPRG((CBNL)n1); CPRG(' '); CPRG((CBNL)n2);
        CPRG(' '); CPRG((CBNL)nb1); CPRG(' '); CPRG((CBNL)nb2);
        if (nb1 < nb2 || p2p <= (               // Сравнение числа битов.
            p1h = _ushldCBNL (p1l, p1h, nb2))   // Сдвиг делимого как делителя.
            && p2p)                             // Если делитель не больше,
        { pa [1] = 1; CPRG(" 1");               // то увеличение частного и
          cBigNumberMAddM (p, EXPTRTO(CBNL, pa, 3), n2 - k2);
          (*pfNumberMSubM)(p1, pp2, n2);        // вычитание делителя.
          continue;
        }                                       // Если делитель стал больше
        if (n2 == k2) break;                    // и деление не завершено, то
//      сдвиг второго старшего слова делимого и деление дает множитель для
//      делителя (слово частного). В специальном случае p2p == 0 результат
//      требуемого сдвига на слово уже находится в  p1h.
        if (p2p) {
          p1l = _ushldCBNL ((n1 > 2 ? p1 [n1 - 2] : 0), p1l, nb2);
          p1h = _udivdCBNL (p1l, p1h, p2p, (unsigned CBNL *)pa + 1);
        }                                       // Множитель для делителя.
        CPRG(' '); CPRG((CBNL)p1h);             // Уменьшение сдвига делителя,
        p [n2-- - k2] = p1h;                    // запоминание слова частного.
        cBigNumberMSubMulM (p1, pp2, p1h, n2);  // Уменьшение остатка.

//      При оценке младших слов делителя можно получить ненулевое старшее
//      слово остатка, если nb2 = 0. В этом редком случае мы должны сделать
//      дополнительное вычитание делителя и приращение частного.

        if (p1 [n1--] != 0) {                   // Если старшее слово не 0,
          pa [1] = 1; CPRG("+1");               // то увеличение частного и
          cBigNumberMAddM (p, EXPTRTO(CBNL, pa, 3), n2 - k2);
          (*pfNumberMSubM)(p1, pp2, n2);        // вычитание делителя.
          assert (p1 [n1 + 1] == 0);            // Остаток укоротился на слово.
        }
      }                                         // Конец основного цикла.

//      Сравнение остатка и делителя, поскольку цикл может быть завершен
//      когда остаток равен делителю или немного больше.

      n2 = n1 - n2;                             // Восстановление n2 как числа
      assert (n1 == n2 + k2 && n2 > 0);         // слов в беззнаковом pp2.
      do continue; while ((p1h = p1 [n2 + k2]) == (p2p = pp2 [n2]) && --n2);
      if (p1h >= p2p) {                         // Если остаток не меньше,
        pa [1] = 1; CPRG("+1");                 // то увеличение частного и
        cBigNumberMAddM (p, EXPTRTO(CBNL, pa, 3), 0);
        (*pfNumberMSubM)(p1, pp2, k2);          // вычитание делителя.
      }
    }
    else if (n1 - 1 > k2) // n2 == 1            // Однословный делитель,
    {                                           // многословное делимое.
      n2 = n1 - 1;                              // Сдвиг делителя (слова).
      do                                        // Основной цикл деления.
      {                                         // Старшее слово частного,
        unsigned CBNL p1h = p1 [n2 + 1];        // множитель для делителя
        CPRG('\n'); CPRG((CBNL)n2);             // и слово частного.
        if (p2p <= p1h) {                       // Если делитель не больше,
          p1h /= p2p;                           // то деление старшего слова
          pa [1] = p1h;                         // и накопление частного,
          cBigNumberMAddM (p, EXPTRTO(CBNL,pa,3), n2 - k2);
        } else {                                // иначе деление старших слов,
          p1h = _udivdCBNL (p1 [n2], p1h, p2p, (unsigned CBNL *)pa + 1);
          p [n2-- - k2] = p1h;                  // уменьшение сдвига делителя и
        }                                       // запоминание слова частного.
        CPRG(' '); CPRG((CBNL)p1h);
        cBigNumberMSubMulM (p1, pp2, p1h, n2);  // Уменьшение остатка.
      }
      while (n2 > k2);                          // Конец основного цикла.
    }
    else // n1 == k2 + 1 && n2 == 1             // Простое однословное деление.
    {
      unsigned CBNL p1h = p1 [n1];              // Старшее слово делимого.
      unsigned CBNL pn = p1h / p2p;             // Деление для частного.
      p [1] = pn;                               // Запоминание частного.
#ifdef  _CBIGNUM_REVERSE_MOD
      p1h -= pn * p2p;                          // Вычисление остатка.
#else //_CBIGNUM_REVERSE_MOD
      p1h %= p2p;                               // Вычисление остатка.
#endif//_CBIGNUM_REVERSE_MOD
      p1 [n1] = p1h;                            // Запоминание остатка.
    }

    // Нормализация остатка.

    while (p1 [n1] == 0 && n1 > 1) --n1;        // Исключение старших 0-слов.
    p1 [0] = n1 + (p1 [n1] < 0);                // Резервирование слова для знака.
    if (signrem < 0) cBigNumberNeg (p1, p1);    // Установка знака остатка.

#endif//_CBIGNUM_SUBMUL_DIV

    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.

    cBigNumberFit (p);                          // Нормализация частного.
    assert (p [(size_t)(*p)] >= 0);             // Проверка неотрицательности.
    if (signquot < 0) cBigNumberNeg (p, p);     // Установка знака частного.

#ifdef  _CBIGNUM_SMALL_DIV
    return;
  }

//      Оптимизированные алгоритмы для однословного или двухсловного
//      ненулевого делителя.

  unsigned CBNL p1h = p1 [n1];                  // Старшее слово делимого.
  CBNL signquot = p1h ^ p2h;                    // Знак частного.

//      Алгоритмы для делимого, которое не длиннее делителя.
//      В этом случае получается однословное частное или двухсловное
//      частной со старшим словом 0 или ~0.

  if (n1 <= n2)                                 // Делимое не длиннее делителя.
  {
    unsigned CBNL pn = 0;                       // Однословное частное.

//      Если делимое короче делителя, то делить не надо,
//      кроме случая ненормализованного делителя.

CompareSize:
    if (n1 == n2)                               // Сравнение размера.

//      Выбираем алгоритм для двухсловного или однословного деления.

#if _CBIGNUM_SMALL_DIV > 1
    switch (n1)
#endif//_CBIGNUM_SMALL_DIV
    {
#if _CBIGNUM_SMALL_DIV > 1
    case 2:                                     // Двухсловное делимое,
    {                                           // двухсловный делитель.
      assert (n1 == 2 && n2 == 2);

      if ((CBNL)p2h == ((CBNL)p2l >> (BITS-1))) // Делитель не нормализован -
        goto LongerDividend;                    // выбираем большее делимое.

      unsigned CBNL p1l = p1 [1];               // Младшее слово делимого.

//     Обеспечиваем положительный знак операндов.

      if ((CBNL)p1h < 0) {
        p1h = ~p1h + ((p1l = -(CBNL)p1l) == 0); // Неотрицательное делимое.
        if ((CBNL)p1h < 0) goto LongerDividend; // Делимое -CBNL_MIN,0 длиннее,
      }                                         // продолжаем с нормализованным
      assert ((CBNL)p1h >= 0);                  // и неотрицательным.

      if ((CBNL)p2h < 0)
        p2h = ~p2h + ((p2l = -(CBNL)p2l) == 0); // Положительный делитель.
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && (p2h | p2l) > 0);

//      Определяем разницу в числе значащих бит.
//      Разница не больше BITS-1, т.к. p1h имеет старший бит 0.

      unsigned CBNL mask = (unsigned CBNL)1;    // Начальная маска.
      CBNC nb = (int)_ulzcntCBNL (p2h) - (int)_ulzcntCBNL (p1h);
      if (nb >= 0)                              // Делимое имеет не меньше
      {                                         // бит, чем делитель.
        assert ((unsigned CBNC)nb < BITS);      // Проверка границ сдвига.
        p2h = _ushldCBNL (p2l, p2h, nb);        // Выравнивание делителя.
        p2l = _ushlCBNL (p2l, nb);
        mask = _ushlCBNL (mask, nb);
        do                                      // Цикл по битам частного.
        {                                       // Если остаток не меньше,
          unsigned CBNL pnh, pnl;               // то вычитание делителя и
          _sbbCBNL (_subCBNL (p1l, p2l, &pnl), p1h, p2h, &pnh);
          if ((CBNL)pnh >= 0) p1h = pnh; p1l = (CBNL)pnh >= 0? pnl: p1l;
          pn += ((CBNL)pnh >= 0)? mask: 0;      // установка бита частного.
        }
        while ((p2l = _ushrd1CBNL (p2l, p2h),
                p2h >>= 1, mask >>= 1) != 0);   // Конец цикла по битам.
      }

      assert ((CBNL)p1h >= 0);                  // Проверка неотрицательности.
      if (p1 [2] < 0)                           // Установка знака остатка.
        p1h = ~p1h + ((p1l = -(CBNL)p1l) == 0);
      p1 [0] = 1 + ((CBNL)p1h != ((CBNL)p1l >> (BITS-1)));
      p1 [1] = p1l; p1 [2] = p1h;               // Запоминание остатка.
      assert (cBigNumberIsFit (p1));            // Проверка нормализованности.
      break; /* switch */
    }

//      Однословное деление может быть аппаратным, если это разрешено.

    default: /* n1 == 1 */                      // Однословный делитель,
                                                // однословное делимое.
#endif//_CBIGNUM_SMALL_DIV
      assert (n1 == 1 && n2 == 1);

//     Обеспечиваем положительный знак операндов.

      if ((CBNL)p1h < 0) p1h = -(CBNL)p1h;      // Неотрицательное делимое.
      assert (p1h <= (unsigned CBNL)(CBNL_MIN));

      if ((CBNL)p2h < 0) p2h = -(CBNL)p2h;      // Положительный делитель.
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && p2h != 0);

#ifdef  _CBIGNUM_HARDWARE_DIV
#ifdef  _CBIGNUM_REVERSE_MOD
      pn = p1h / p2h; p1h -= pn * p2h;          // Частное и остаток.
#else //_CBIGNUM_REVERSE_MOD
      pn = p1h / p2h; p1h %= p2h;               // Частное и остаток.
#endif//_CBIGNUM_REVERSE_MOD
#else //_CBIGNUM_HARDWARE_DIV

//      Определяем разницу в числе значащих бит.
//      Разница не больше BITS-1, т.к. p2h не больше 0.

      unsigned CBNL mask = (unsigned CBNL)1;    // Начальная маска.
      CBNC nb = (int)_ulzcntCBNL (p2h) - (int)_ulzcntCBNL (p1h);
      if (nb >= 0)                              // Делимое имеет не меньше
      {                                         // бит, чем делитель.
        assert ((unsigned CBNC)nb < BITS);      // Проверка границ сдвига.
        p2h <<= nb; mask <<= nb;                // Выравнивание делителя.
        do                                      // Цикл по битам частного.
        {
          CBNL pnh = p1h - p2h;                 // Если остаток не меньше,
          if (pnh >= 0) p1h = pnh;              // то вычитание делителя и
          pn += (pnh >= 0)? mask: 0;            // установка бита частного.
        }
        while ((p2h >>= 1, mask >>= 1) != 0);   // Конец цикла по битам.
      }
#endif//_CBIGNUM_HARDWARE_DIV

      assert (p1h <= (unsigned CBNL)(CBNL_MIN));
      if (p1 [1] >= 0) p1 [1] = p1h;            // Запоминание остатка.
      else             p1 [1] = -(CBNL)p1h;     // Установка знака остатка.
    }
    else if ((CBNL)p2h == ((CBNL)p2l >> (BITS-1)) ||
             p2h == 0 && p2l == (((unsigned CBNL)1) << (BITS-1)))
    {                                           // Удаляем лишнее старшее слово
      p2h = p2l; --n2; goto CompareSize;        // у более длинного делителя
    }                                           // и сравниваем размеры снова.

    if (signquot >= 0)                          // Запоминание частного.
    if ((CBNL)pn >= 0)
         { p [0] = 1; p [1] = pn; }             // Однословное частное.
    else { p [0] = 2; p [1] = pn; p [2] = 0; }  // Добавляем знаковое слово.
    else                                        // Установка знака частного.
    if (-(CBNL)pn <= 0)
         { p [0] = 1; p [1] = -(CBNL)pn; }      // Однословное частное.
    else { p [0] = 2; p [1] = -(CBNL)pn; p [2] = ~(CBNL)0; }
    assert (cBigNumberIsFit (p));               // Проверка нормализованности.
  }

//      Алгоритмы для многословного делимого, которое длиннее делителя состоят
//      из двух частей. Первая часть сокращает делимое или остаток до размеров
//      делителя, а вторая заканчивает деление при одинаковых размерах.

  else /* n1 > n2 */                            // Делимое длиннее делителя.
  {
#if _CBIGNUM_SMALL_DIV > 1
LongerDividend:
#endif//_CBIGNUM_SMALL_DIV
    if ((CBNL)p1h < 0) {                        // Для отрицательного делимого
      p1 [0] = p1h;                             // сохраняем знак делимого и
      size_t n = 0;                             // берем абсолютное значение.
      do ++n; while ((p1 [n] = p1h = -p1 [n]) == 0); ++n;
      if (n <= n1) do p1 [n] = p1h = ~p1 [n]; while (++n <= n1);
      else if ((CBNL)p1h < 0) { p1h = 0; ++n1; }// Добавляем старшее слово к
    }                                           // -CBNL_MIN, нормализуя до
    assert ((CBNL)p1h >= 0);                    // неотрицательного делимого.

//      Сдвиг делимого влево до максимального значения со старшим битом 0.

    CBNC nb1 = (int)_ulzcntCBNL (p1h) - 1;      // Сдвиг делимого влево.
    assert ((unsigned CBNC)nb1 < BITS);         // Проверка границ сдвига.

//      Выбираем алгоритм для двухсловного или однословного делителя.

#if _CBIGNUM_SMALL_DIV > 1
    switch (n2)
#endif//_CBIGNUM_SMALL_DIV
    {
#if _CBIGNUM_SMALL_DIV > 1
    case 2:                                     // Многословное делимое,
    if ((CBNL)p2h != ((CBNL)p2l >> (BITS-1)))   // двухсловный делитель,
    {                                           // который нормализован.
      assert (n1 > 2);

      if ((CBNL)p2h < 0)
        p2h = ~p2h + ((p2l = -(CBNL)p2l) == 0);
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && (p2h | p2l) > 0);

//      Делитель сдвигается влево до максимального значения со старшим битом 0.
//      Исключением является делитель -CBNL_MIN,0 который остается как есть.

      CBNC nb2 = (int)_ulzcntCBNL (p2h) - 1;    // Сдвиг делителя влево.
      if (nb2 < 0) nb2 = 0;                     // Случай -CBNL_MIN,0.
      assert ((unsigned CBNC)nb2 < BITS);       // Проверка границ сдвига.
      p2h = _ushldCBNL (p2l, p2h, nb2);         // Сдвиг старшего слова.
      p2l = _ushlCBNL (p2l, nb2);               // Сдвиг младшего слова.
      assert (p2h >= (((unsigned CBNL)1) << (BITS-2)));

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

      *p = (CBNL)n1; p += n1;                   // Длина n1 - n2 + 2.
      *p-- = 0;                                 // Начало заполнения p.

      CBNC nb = nb2 - nb1;                      // Разница между сдвигами.
      if (nb < 0) {                             // Если слово делимого короче,
        *p-- = 0; nb += BITS;                   // то обнуление слова частного.
      }                                         // Начальная маска.
      unsigned CBNL mask = ((unsigned CBNL)1) << nb;
      assert ((unsigned CBNC)nb < BITS);        // Проверка границ сдвига.

//      Делимое сдвигается влево до максимального значения со старшим битом 0.

      unsigned CBNL p1l = p1 [--n1];            // Предыдущее слово делимого.
      unsigned CBNL p1n = 0;                    // Следующее слово делимого.
      if (nb1 > 0)                              // Сдвиг делимого влево до
      {                                         // единственного старшего 0-бита.
        p1n = p1 [--n1];                        // Следующее слово делимого.
        p1h = _ushldCBNL (p1l, p1h, nb1);       // Сдвиг старшего слова делимого,
        p1l = _ushldCBNL (p1n, p1l, nb1);       // предыдущего слова делимого
        p1n = _ushlCBNL (p1n, nb1);             // и следующего за ним слова.
        nb1 -= BITS;
      }
      assert (p1h >= (((unsigned CBNL)1) << (BITS-2)));

//      Строим значащие слова частного в процессе вычисления остатка.

      unsigned CBNL pn = 0;                     // Очередное слово частного.
      for (;;)                                  // Цикл по битам частного.
      {                                         // Если остаток не меньше,
        unsigned CBNL pnh, pnl;                 // то вычитание делителя и
        _sbbCBNL (_subCBNL (p1l, p2l, &pnl), p1h, p2h, &pnh);
        if ((CBNL)pnh >= 0) p1h = pnh; p1l = (CBNL)pnh >= 0? pnl: p1l;
        pn += ((CBNL)pnh >= 0)? mask: 0;        // установка бита частного.
        if (++nb1 > 0)                          // Биты закончились.
        {
          if (--n1 == 0) break;                 // Слова делимого закончились.
          p1n = p1 [n1]; nb1 -= BITS;           // Следующее слово делимого.
        }
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l = _ushld1CBNL (p1n, p1l);
        p1n += p1n;
        if (!(mask >>= 1))                      // Сдвиг маски вправо.
        {                                       // Слово частного готово.
          *p-- = pn; pn = 0;                    // Запоминание слова частного.
          mask = ((unsigned CBNL)1) << (BITS-1);// Начальная маска.
        }
      }                                         // Конец цикла по битам.

//      Двухсловное деление для остатка из двух слов.

      while ((p2l = _ushrd1CBNL (p2l, p2h),
              p2h >>= 1, mask >>= 1) != 0)      // Цикл по битам частного.
      {                                         // Если остаток не меньше,
        unsigned CBNL pnh, pnl;                 // то вычитание делителя и
        _sbbCBNL (_subCBNL (p1l, p2l, &pnl), p1h, p2h, &pnh);
        if ((CBNL)pnh >= 0) p1h = pnh; p1l = (CBNL)pnh >= 0? pnl: p1l;
        pn += ((CBNL)pnh >= 0)? mask: 0;        // установка бита частного.
      }                                         // Конец цикла по битам.
      *p-- = pn;                                // Последнее слово частного.

      assert ((CBNL)p1h >= 0);                  // Проверка неотрицательности.
      if (p1 [0] < 0) {                         // Установка знака остатка.
        p1h = ~p1h + ((p1l = -(CBNL)p1l) == 0);
      }
      p1 [0] = 1 + ((CBNL)p1h != ((CBNL)p1l >> (BITS-1)));
      p1 [1] = p1l; p1[2] = p1h;                // Запоминание остатка.
      assert (cBigNumberIsFit (p1));            // Проверка нормализованности.
      break; /* switch */
    }                                           // Удаление старшего слова
    p2h = p2l;                                  // ненормализованного делителя.

//      Алгоритм для однословного делителя может использовать аппаратное
//      деление, если оно разрешено.

    default: /* n2 == 1 */                      // Многословное делимое,
                                                // однословный делитель.
#endif//_CBIGNUM_SMALL_DIV
      assert (n1 > 1);
      unsigned CBNL p1l = 0;                    // Следующее слово делимого.

      if ((CBNL)p2h < 0) p2h = -(CBNL)p2h;      // Положительный делитель.
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && p2h > 0);

//      Сдвиг делителя влево до максимального значения со старшим битом 0.
//      Исключением является делитель -CBNL_MIN, который остается как есть.

      CBNC nb2 = (int)_ulzcntCBNL (p2h) - 1;    // Сдвиг делителя влево.
      if (nb2 < 0) nb2 = 0;                     // Случай -CBNL_MIN.
      assert ((unsigned CBNC)nb2 < BITS);       // Проверка границ сдвига.

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

      *p = (CBNL)(n1 + 1); p += (n1 + 1);       // Длина n1 - n2 + 2.
      *p-- = 0;                                 // Начало заполнения p.

//      Алгоритм реализован в двух модификациях в зависимости от
//      доступности аппаратного деления двойного слова на однословное.

#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)

//      Если делитель не короче делимого, сдвинутого влево на слово,
//      то проводится предварительное бинарное деление.

    if (n1 > 2 || nb2 >= nb1)
    {
#endif

      CBNC nb = nb2 - nb1;                      // Разница между сдвигами.
      if (nb < 0) {                             // Если слово делимого короче,
        *p-- = 0; nb += BITS;                   // то обнуление слова частного.
      }                                         // Начальная маска.
      unsigned CBNL mask = ((unsigned CBNL)1) << nb;
      assert ((unsigned CBNC)nb < BITS);        // Проверка границ сдвига.

//      Делимое и делитель сдвигаются влево.

      if (nb1 > 0)                              // Сдвиг делимого влево до
      {                                         // единственного старшего 0-бита.
        p1l = p1 [--n1];                        // Следующее слово делимого.
        p1h = _ushldCBNL (p1l, p1h, nb1);       // Сдвиг старшего слова делимого
        p1l = _ushlCBNL (p1l, nb1);             // и следующего за ним слова.
        nb1 -= BITS;
      }
      assert (p1h >= (((unsigned CBNL)1) << (BITS-2)));
      p2h <<= nb2;                              // Сдвиг делителя.
      assert (p2h >= (((unsigned CBNL)1) << (BITS-2)));

//      Строим значащие слова частного в процессе вычисления остатка.

      unsigned CBNL pn = 0;                     // Очередное слово частного.
      for (;;)                                  // Цикл по битам частного.
      {
        CBNL pnh = p1h - p2h;                   // Если остаток не меньше,
        if (pnh >= 0) p1h = pnh;                // то вычитание делителя и
        pn += (pnh >= 0)? mask: 0;              // установка бита частного.
        if (++nb1 > 0)                          // Биты закончились.
        {
#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
          p1l = p1 [--n1]; nb1 -= BITS;         // Следующее слово делимого.
#else
          if (--n1 == 0) break;                 // Слова делимого закончились.
          p1l = p1 [n1]; nb1 -= BITS;           // Следующее слово делимого.
#endif
        }
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l += p1l;
        if (!(mask >>= 1))                      // Сдвиг маски вправо.
        {                                       // Слово частного готово.
          *p-- = pn; pn = 0;                    // Запоминание слова частного.
#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
          if (n1 <= 1) break;                   // Последнее слово частного.
#endif
          mask = ((unsigned CBNL)1) << (BITS-1);// Начальная маска.
        }
      }                                         // Конец цикла по битам.
#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
      nb1 += BITS;
      p1l = _ushrdCBNL (p1l, p1h, nb1);         // Не сдвинутый остаток.
      p1h = _ushrCBNL (p1h, nb1);
      p2h = _ushrCBNL (p2h, nb2);               // Исходный делитель.
    }
    else { p1l = p1 [1]; *p-- = 0; }            // Обнуление слова частного.

//      Деление двухсловного числа на однословное.

      assert (p1h < p2h);                       // Проверка переполнения.
      *p-- = _udivdCBNL (p1l, p1h, p2h, (unsigned CBNL*)EXPTRBASE(p1) + 1);
      assert (p1 [1] >= 0);                      // Частное и остаток.
      if (p1 [0] < 0) p1 [1] = -p1 [1];         // Установка знака остатка.

#else //_CBIGNUM_HARDWARE_DIV && _CBNL_DIV

//      Однословное деление для остатка из одного слова.

#ifdef  _CBIGNUM_HARDWARE_DIV
      if (nb2 >= _CBNL_HARDDIV_BITS)            // Аппаратное деление при
      {                                         // наличии старших 0-бит.
        p2h >>= nb2;                            // Исходный делитель.
#ifdef  _CBIGNUM_REVERSE_MOD
        unsigned CBNL pl = p1h / p2h;           // Деление.
        pn |= pl; p1h -= pl * p2h;              // Частное и остаток.
#else //_CBIGNUM_REVERSE_MOD
        pn |= p1h / p2h; p1h %= p2h;            // Частное и остаток.
#endif//_CBIGNUM_REVERSE_MOD
      }
      else                                      // Бинарное деление.
#endif//_CBIGNUM_HARDWARE_DIV && _CBNL_DIV
      while ((p2h >>= 1, mask >>= 1) != 0)      // Цикл по битам частного.
      {
        CBNL pnh = p1h - p2h;                   // Если остаток не меньше,
        if (pnh >= 0) p1h = pnh;                // то вычитание делителя и
        pn += (pnh >= 0)? mask: 0;              // установка бита частного.
      }                                         // Конец цикла по битам.
      *p-- = pn;                                // Последнее слово частного.

      assert ((CBNL)p1h >= 0);                  // Проверка неотрицательности.
      if (p1 [0] >= 0) p1 [1] = p1h;            // Запоминание остатка.
      else             p1 [1] = -(CBNL)p1h;     // Установка знака остатка.

#endif//_CBIGNUM_HARDWARE_DIV || _CBNL_DIV

      p1 [0] = 1;                               // Число слов в остатке.
    }

    cBigNumberFit (p);                          // Нормализация частного.
    assert (p [(size_t)(*p)] >= 0);             // Проверка неотрицательности.
    if (signquot < 0) cBigNumberNeg (p, p);     // Установка знака частного.
  }
#endif//_CBIGNUM_SMALL_DIV
}

//================================================
//      Функции вычисления остатка.
//================================================

//      Специализированная функция остатка с таблицей сдвигов.
//      Предполагается, что делимое и делитель имеют одинаковый знак,
//      за исключением случая деления отрицательного числа на 0.
//      В буфере делителя должна находиться таблица сдвигов,
//      полученная функцией cBigNumberTab.
//
//      Функция вычисления остатка является сокращенным вариантом
//      функции деления, из которой исключено вычисление частного.
//      Функция заносит остаток на место делимого.
//      Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованный остаток.

void    cBigNumberMModShlTab (                  // Остаток p1 %= p2<< k2*BITS.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель и таблица сдвигов.
                        size_t      k2          // Сдвиг делителя влево.
        )                                       // p1, p2 не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p2);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  size_t n = n2 + k2;                           // Число слов после сдвига.
  if (n > n1) n = n1;                           // Делимое короче делителя.
  n = n1 - n + 1 + k2;                          // Сдвиг делителя.

  if (n2 >= cBigNumberSkipLow0 (p2))            // Пропуск младших 0-слов и
  {                                             // проверка деления на 0.
    CBNL p2h = p2 [n2];                         // Старшее слово делителя.
    assert ((p1 [n1] ^ p2h) >= 0);              // Совпадение знаков.
    CBNL lt = (p2h < 0) * 2 - 1;                // Константа для сравнения
                                                // абсолютных значений чисел.
                                                // (p1 и p2 >= 0)? -1: 1
    p2h ^= (p2h >> (BITS-1));                   // Инверсия при p2 < 0.
    size_t nn2 = n + n2;                        // Размер сдвинутого делителя
    p2h = ((CBNL)1) << (_ulzcntCBNL(p2h) - 1);  // и маска его уменьшения на 1.
    n2 += 2;                                    // Шаг по таблице сдвигов.

    do                                          // Цикл по словам.
    {
      p2 += n2 * BITS; --n;                     // Подготовка цикла по битам.
      unsigned CBNL mask = ((unsigned CBNL)1) << (BITS-1);
                                                // Начальная маска.
      do                                        // Цикл по битам.
      {                                         // Вычисление разности размеров
        p2 -= n2;                               // после сдвига делителя на бит.
        CBNL diff = nn2 - ((unsigned CBNL)p2h >= mask) - n1;
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, p2, n) != lt)) // сдвинутого делителя,
        {                                       // то вычитание делителя.
          assert (diff < 0 ? p1 [n1] == p2 [(size_t)(*p2) + 1] : 1);
          // Предусловие вызова _cBigNumberMSubD() в альтернативном варианте.
          // В случае различных размеров делитель должен иметь резервное
          // слово расширения знака, аналогичное старшему слову делимого.
          // Резервное слово формируется cBigNumberTab() для сдвигов в
          // начале таблицы до увеличения размера на 1, далее не требуется.
          n1 = _cBigNumberMSubD (p1, p2, n);    // Вычитание делителя.
          p1 [0] = (CBNL) n1;                   // Запоминание размера.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
      --nn2;                                    // Слово завершено.
    }
    while (n > k2);                             // Конец цикла по словам.

    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, p2) == lt);     // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
  }                                             // будет равен делимому.

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

#ifdef  _CBNL_TAB_FULL

//      Специализированная функция остатка с половинной таблицей сдвигов.
//
//      Метод использует сдвинутый на полслова дополнительный код чисел из
//      первой половины таблицы сдвигов вместо второй половинной таблицы.
//
//      Сдвинутый код не содержит правильно расположенное слово с длиной,
//      поэтому надо вычислять длину сдвинутого делителя вместо чтения.
//      Поскольку чтение невыровненных слов работает медленнее, чем для
//      выровненных слов, то этот метод только для экономии памяти.

void    cBigNumberMModShlTab2 (                 // Остаток p1 %= p2<< k2*BITS.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель и таблица сдвигов.
                        size_t      k2          // Сдвиг делителя влево.
        )                                       // p1, p2 не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p2);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  size_t n = n2 + k2;                           // Число слов после сдвига.
  if (n > n1) n = n1;                           // Делимое короче делителя.
  n = n1 - n + 1 + k2;                          // Сдвиг делителя.

  if (n2 >= cBigNumberSkipLow0 (p2))            // Пропуск младших 0-слов и
  {                                             // проверка деления на 0.
    CBNL p2h = p2 [n2];                         // Старшее слово делителя.
    assert ((p1 [n1] ^ p2h) >= 0);              // Совпадение знаков.
    CBNL lt = (p2h < 0) * 2 - 1;                // Константа для сравнения
                                                // абсолютных значений чисел.
                                                // (p1 и p2 >= 0)? -1: 1
    p2h ^= (p2h >> (BITS-1));                   // Инверсия при p2 < 0.
    size_t nn2 = n + n2;                        // Размер сдвинутого делителя
    p2h = ((CBNL)1) << (_ulzcntCBNL(p2h) - 1);  // и маска его уменьшения на 1.
    n2 += 2;                                    // Шаг по таблице сдвигов.
    p2 += n2 * BITS/2;                          // Конец таблицы сдвигов.

    do                                          // Цикл по словам.
    {
      const CBNL* pp2 = (const CBNL*)           // Сдвинутый на полслова p2.
                        ((const int*)(CBPTRBASE(p2)) - 1);
      --n;                                      // Сдвиг pp2.
      unsigned CBNL mask = ((unsigned CBNL)1) << (BITS-1);
                                                // Начальная маска.
      do                                        // Цикл по старшим сдвигам.
      {                                         // Вычисление разности размеров
        pp2 -= n2;                              // после сдвига делителя на бит.
        CBNL diff = nn2 - ((unsigned CBNL)p2h >= mask) - n1;
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, pp2, n) != lt))// сдвинутого делителя,
        {                                       // то вычитаем делитель.
          n1 = _cBigNumberMSubD (p1, pp2, n);   // Вычитание делителя.
          p1 [0] = (CBNL) n1;                   // Запоминание размера.
        }
      }
      while ((unsigned)(mask >>= 1) == 0);      // Конец цикла по сдвигам.

      pp2 = CBPTRBASE(p2);                      // Не сдвинутый p2.
      do                                        // Цикл по младшим сдвигам.
      {                                         // Вычисление разности размеров
        pp2 -= n2;                              // после сдвига делителя на бит.
        CBNL diff = nn2 - ((unsigned CBNL)p2h >= mask) - n1;
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, pp2, n) != lt))// сдвинутого делителя,
        {                                       // то вычитаем делитель.
          assert (diff < 0 ? p1 [n1] == pp2 [(size_t)(*pp2) + 1] : 1);
          // Предусловие вызова _cBigNumberMSubD() в альтернативном варианте.
          // В случае различных размеров делитель должен иметь резервное
          // слово расширения знака, аналогичное старшему слову делимого.
          // Резервное слово формируется cBigNumberTab() для сдвигов в
          // начале таблицы до увеличения размера на 1, далее не требуется.
          n1 = _cBigNumberMSubD (p1, pp2, n);    // Вычитание делителя.
          p1 [0] = (CBNL) n1;                   // Запоминание размера.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по сдвигам.
      --nn2;                                    // Слово завершено.
    }
    while (n > k2);                             // Конец цикла по словам.

    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, p2) == lt);     // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
  }                                             // будет равен делимому.

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

#endif//_CBNL_TAB_FULL

#if !defined(_CBIGNUM_HARDWARE_DIV) || !defined(_CBNL_DIV)

//================================================
//      Реализация одинарного модуля двойного слова
//      через аддитивные операции в Cbignumf,
//      для всего класса при отключении _CBNL_DIV.
//================================================

#ifndef NCHECKPTR
#ifdef  __cplusplus
extern "C" {
#endif//__cplusplus
#endif//NCHECKPTR

#undef  _moddCBNL
#define _moddCBNL   _moddCBNL_c
#undef  _umoddCBNL
#define _umoddCBNL  _umoddCBNL_c

//      Остаток от деления двойного слова CBNL на одинарное слово.
//      При переполнении однословного частного или делении на 0, если
//      ошибки деления разрешены, остаток равен младшему слову делимого.
//
//      Две реализации через неограниченное и оптимизированное деление.

#ifndef _CBNL_SMALL_DIV

//      Реализация через модуль неограниченных чисел, менее эффективная.
//      Установка _CBIGNUM_SMALL_DIV исключает рекурсию _CBIGNUM_SUBMUL_DIV
//      и рекомендуется для увеличения производительности.

#ifdef  _CBIGNUM_SUBMUL_DIV
#if !defined(_CBIGNUM_SMALL_DIV) || _CBIGNUM_SMALL_DIV < 2
#undef  _CBIGNUM_SMALL_DIV
#define _CBIGNUM_SMALL_DIV 2
#endif//_CBIGNUM_SMALL_DIV
#endif//_CBIGNUM_SUBMUL_DIV

//      Функция модуля двойного слова.
//      Вызывается как _moddCBNL

CBNL   _CBNL_C  _moddCBNL_c (                   // Остаток ll,lh % l2.
                        CBNL    ll,             // Младшее слово делимого.
                        CBNL    lh,             // Старшее слово делимого.
                        CBNL    l2              // Делитель.
        )                                       // Выдает остаток.
{                                               // Буфер для делимого
  CBNL c1 [5]; c1 [0] = 2; c1 [1] = ll; c1 [2] = lh;    // и остатка.
  CBNL c2 [3]; c2 [0] = 1; c2 [1] = l2;         // Буфер для делителя.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);

  cBigNumberFit (pp1);                          // Нормализация.
  cBigNumberMMod (pp1, pp2);                    // Модуль.

  return c1 [1];                                // Остаток.
}

//      Функция модуля беззнакового двойного слова.
//      Вызывается как _umoddCBNL

unsigned
CBNL   _CBNL_C  _umoddCBNL_c (                  // Остаток ll,lh % l2.
                unsigned CBNL   ll,             // Младшее слово делимого.
                unsigned CBNL   lh,             // Старшее слово делимого.
                unsigned CBNL   l2              // Беззнаковый делитель.
        )                                       // Выдает беззнаковый остаток.
{                                               // Буфер для делимого и
  CBNL c1 [5]; c1 [0] = 3; c1 [1] = ll; c1 [2] = lh; c1 [3] = 0; // остатка.
  CBNL c2 [4]; c2 [0] = 2; c2 [1] = l2; c2 [2] = 0; // Буфер для делителя.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);

  cBigNumberFit (pp1);                          // Нормализация.
  cBigNumberMMod (pp1, pp2);                    // Модуль.

  return c1 [1];                                // Остаток.
}

#else //_CBNL_SMALL_DIV

//      Оптимизированная функция модуля беззнакового двойного слова.
//      Call as _umoddCBNL

unsigned
CBNL   _CBNL_C  _umoddCBNL_c (                  // Деление ll,lh /% l2.
                unsigned CBNL   p1l,            // Младшее слово делимого.
                unsigned CBNL   p1h,            // Старшее слово делимого.
                unsigned CBNL   p2h             // Беззнаковый делитель.
        )                                       // Выдает беззнаковый остаток.
{
//      Беззнаковый делитель может задействовать все биты слова CBNL,
//      что требует специальной обработки. Сначала упрощаем алгоритмы
//      проверкой переполнения и деления на 0.

  if (p1h < p2h)                                // Проверка ошибки деления.
  {
//      Деление двойного слова на одинарное.

    if (p1h != 0)                               // Двухсловный делитель,
    {                                           // однословное делимое.
      CBNC nb = (int)_ulzcntCBNL (p1h) - (int)_ulzcntCBNL (p2h);
      assert (nb >= 0);                         // Разница в значащих битах.

//      Добавляем сдвиг делимого при одинаковом числе значащих бит, т.к.
//      p1h < p2h и запоминаем старший бит если делитель занимает все слово.

      unsigned CBNL pnc = (nb == 0? p2h: 0);    // Запоминание старшего бита.
      nb += (nb == 0);                          // Добавочный сдвиг.
      p1h = _ushldCBNL (p1l, p1h, nb);          // Выравнивание делимого.
      p1l = _ushlCBNL (p1l, nb);
      nb = BITS - nb;                           // Счетчик цикла.

//      Алгоритм с дополнительными битом остатка для делителя во все слово.

      if ((CBNL)p2h < 0)                        // Делитель во все слово.
      for (;;)                                  // Цикл по битам.
      {
        unsigned CBNL pnh = p1h - p2h;          // Если остаток с дополни-
        pnc |= (p1h >= p2h? p2h: 0);            // тельным битом не меньше,
        if ((CBNL)pnc < 0) p1h = pnh;           // то вычитание делителя.
        if (--nb < 0) break;                    // Биты закончились.
        pnc = p1h;                              // Запоминание старшего бита.
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l += p1l;
      }                                         // Конец цикла по битам.

//      Алгоритм для более короткого делителя с оптимизированным
//      сравнением путем вычитания (не для общего случая).

      else                                      // Более короткий делитель.
      for (;;)                                  // Цикл по битам.
      {
        unsigned CBNL pnh = p1h - p2h;          // Если остаток не меньше,
        if ((CBNL)pnh >= 0) p1h = pnh;          // то вычитание делителя.
        if (--nb < 0) break;                    // Биты закончились.
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l += p1l;
      }                                         // Конец цикла по битам.
    }

//      Одинарное деление без применения аппаратной операции.

    else if ((p1h = p1l) >= p2h)                // Однословный делитель,
    {                                           // однословное делимое.
      CBNC nb = (int)_ulzcntCBNL (p2h) - (int)_ulzcntCBNL (p1h);
      assert (nb >= 0);                         // Разница в значащих битах.
      p2h <<= nb;                               // Выравнивание делителя.

//      Алгоритм с оптимизированным сравнением путем вычитания для делимого
//      и делителя во все слово или более короткого делителя. Для выполнения
//      этого требования мы убедились, что делимое не меньше делителя.

      for (;;)                                  // Цикл по битам.
      {
        unsigned CBNL pnh = p1h - p2h;          // Если остаток не меньше,
        if ((CBNL)pnh >= 0) p1h = pnh;          // то вычитание делителя
        if (--nb < 0) break;                    // Биты закончились.
        p2h >>= 1;                              // Сдвиг делителя вправо.
      }                                         // Конец цикла по битам.
    }
    assert (p1h < p2h);                         // Проверка остатка.
  }
  else { p1h = p1l; cBigNumberDiv0(); }         // Деление на 0
                                                // или переполнение.
  return p1h;                                   // Остаток.
}

//      Оптимизированная функция модуля двойного слова.
//      Call as _moddCBNL

CBNL   _CBNL_C  _moddCBNL_c (                   // Деление ll,lh /% l2.
                        CBNL    p1l,            // Младшее слово делимого.
                        CBNL    p1h,            // Старшее слово делимого.
                        CBNL    p2h             // Делитель.
        )                                       // Выдает остаток.
{
  CBNL signrem = p1h;                           // Знак делимого/остатка.

  if (p1h < 0) p1h = ~p1h + ((p1l = -p1l) == 0);// Неотрицательное делимое.
  if (p2h < 0) p2h = -p2h;                      // Неотрицательный делитель.
  CBNL p = (CBNL)_umoddCBNL (p1l, p1h, p2h);    // Модуль.
  if (signrem < 0) p = -p;                      // Установка знака остатка.

  return p;                                     // Остаток.
}

#endif//_CBNL_SMALL_DIV

#ifndef NCHECKPTR
#ifdef  __cplusplus
}
#endif//__cplusplus
#endif//NCHECKPTR

#endif//_CBIGNUM_HARDWARE_DIV || _CBNL_DIV

//      Универсальная функция остатка работает с числами любых знаков и
//      не требует наличия предварительно подготовленной таблицы сдвигов.
//      Если это ускоряет операцию, то функция сама строит временную таблицу
//      сдвигов, иначе применяет алгоритм, не использующий таблицу сдвигов.
//
//      Функция вычисления остатка является сокращенным вариантом
//      функции деления, из которой исключено вычисление частного.
//      Функция заносит остаток на место делимого.
//      Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованный остаток.

void    cBigNumberMMod (                        // Остаток p1 %= p2.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток
                                                // в буфере размера *p1 + 3 -
                const   CBPTR(CBNL) p2          // Делитель. (p1 [*p1] == 0);
        )                                       // p1, p2 могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Выделяем младшее и старшее слово делителя, если он короткий.

#ifdef  _CBIGNUM_SMALL_DIV
  unsigned CBNL p2h = 0, p2l = 0;               // Слова делителя или 0.
  if (n2 - 1 <= _CBIGNUM_SMALL_DIV - 1) { p2l = p2 [1];
                                          p2h = p2 [n2]; }

//      Выбираем общие алгоритм для многословного делителя или
//      оптимизированные алгоритмы для ненулевого делителя,
//      содержащего не более _CBIGNUM_SMALL_DIV слов.

  if ((p2h | p2l) == 0)                         // Общий случай деления для
  {                                             // для многословного делителя.
#endif//_CBIGNUM_SMALL_DIV
    cBigTemp cBigBuf2;                          // Выделение временного буфера.
#ifdef _CBIGNUM_SUBMUL_DIV
    cBigBuf2.checkexpand ((size_t)(n2 + 3));
#else //_CBIGNUM_SUBMUL_DIV
#ifdef  _CBIGNUM_SHIFTTAB_DIV
    CBNL nt = (CBNL)((n2 - n1 + _CBNL_TAB_MIN - 1) & (n2 - _CBNL_TAB_MAX));
    cBigBuf2.checkexpand ((size_t)((nt >= 0)? (n2 + 3):
#ifdef  _CBNL_TAB_FULL
                       (n2 > _CBNL_TAB_FULL)? (n2 + 3) * BITS/2 + 1:
#endif//_CBNL_TAB_FULL
                                              (n2 + 3) * BITS + 1));
#else //_CBIGNUM_SHIFTTAB_DIV
    cBigBuf2.checkexpand ((size_t)(n2 + 3));
#endif//_CBIGNUM_SHIFTTAB_DIV
#endif//_CBIGNUM_SUBMUL_DIV
    EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);      // Буфер для делителя.

//      Копирование и нормализация ненулевого делителя с пропуском младших 0-слов.
//      Если делитель 0, то результат содержит 0 слов.

    size_t k2 = cBigNumberCopySkipLow0 (p2, pp2);

#ifndef _CBIGNUM_SUBMUL_DIV

//      Обеспечиваем совпадение знаков делимого и делителя.
//      CBPTRBASE учитывает случай денормализованного нуля в p2.

    if ((p1 [n1] ^ CBPTRBASE(p2)[n2]) < 0) cBigNumberNeg (pp2, pp2);

//      Общий алгоритм с таблицей сдвигов.

#ifdef  _CBIGNUM_SHIFTTAB_DIV
    if (nt < 0)
    {
//      Выбираем экономящий память метод с половинной таблицей сдвигов
//      или метод с полной таблицей.
#ifdef  _CBNL_TAB_FULL
      if (n2 > _CBNL_TAB_FULL)
      {
        _cBigNumberTab (pp2, BITS/2);           // Подготовка таблицы сдвигов.
        cBigNumberMModShlTab2 (p1, pp2, k2);    // Модуль.
      }
      else
#endif//_CBNL_TAB_FULL
      {
        cBigNumberTab (pp2);                    // Подготовка таблицы сдвигов.
        cBigNumberMModShlTab (p1, pp2, k2);     // Модуль.
      }
      return;
    }
#endif//_CBIGNUM_SHIFTTAB_DIV

//      Общий алгоритм, не применяющий таблицу сдвигов.

    n2 = (size_t)(*pp2);                        // Число слов.
    if (n2 == 0)                                // Делитель 0.
    {                                           // Если деление на 0
      cBigNumberDiv0();                         // разрешено, то остаток
      return;                                   // будет равен делимому.
    }
    assert (cBigNumberIsFit (pp2));             // Проверка нормализованности.

    size_t n = n2 + k2;                         // Число слов после сдвига.
    if (n > n1) return;                         // Остаток равен делимому,
                                                // если оно короче делителя.
    n = n1 - n2 + 1;                            // Сдвиг делителя.

    assert ((p1 [n1] ^ pp2 [n2]) >= 0);         // Проверка совпадения знаков.
    CBNL lt = (pp2 [n2] < 0) * 2 - 1;           // Константа для сравнения
                                                // абсолютных значений чисел
                                                // (p1 и pp2 >= 0)? -1: 1
    do                                          // Цикл по словам.
    {
      cBigNumberMShlD (pp2); --n;               // Сдвиг делителя на слово.
      unsigned CBNL mask = ((unsigned CBNL)1) << (BITS-1);
                                                // Начальная маска.
      do                                        // Цикл по битам.
      {
        CBNL diff = (CBNL)cBigNumberMDiv2D (pp2)// Сдвиг делителя на бит.
                  + (CBNL)n - (CBNL)n1;         // Разность размеров.
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
        _cBigNumberCompHigh (p1, pp2, n) != lt))// сдвинутого делителя,
        {                                       // то вычитаем делитель.
          n1 = cBigNumberMSubD (p1, pp2, n);    // Вычитание делителя.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
    }
    while (n > k2);                             // Конец цикла по словам.

    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.

#else //_CBIGNUM_SUBMUL_DIV

//      Новый алгоритм с умножением.

    #undef  CPRG
    #define CPRG(a)

    n2 = (size_t)(*pp2);                        // Число слов.
    if (n2 == 0)                                // Делитель 0.
    {                                           // Если деление на 0
      cBigNumberDiv0();                         // разрешено, то остаток
      return;                                   // будет равен делимому.
    }
    assert (cBigNumberIsFit (pp2));             // Проверка нормализованности.

//      Делаем делитель положительным и беззнаковым.

    unsigned CBNL p2p = pp2 [n2];               // Старшее слово делителя.
    if ((CBNL)p2p < 0) {
      n2 = cBigNumberNeg (pp2, pp2);            // Смена знака делителя
      p2p = pp2 [n2];                           // и новое старшее слово.
    }                                           // Исключение старшего 0-слова.
    void _CBNL_C (*pfNumberMSubM)(EXPTR(CBNL), const CBPTR(CBNL), size_t);
    if (p2p != 0) {                             // Исключение старшего 0-слова
      pfNumberMSubM = cBigNumberMSubM;          // и выбор специальной функции
    } else {                                    // для беззнакового вычитания.
      pfNumberMSubM = cBigNumberMSubMM; p2p = pp2 [--n2]; *pp2 = (CBNL)n2;
    }
    assert (pp2 [n2] != 0 && n2 > 0);

//      Проверяем, что делимое не короче делителя.

    CBNL signrem = p1 [n1];                     // Знак делимого/остатка.
    if (n1) n1 -= (signrem == 0);               // Не считаем старшее 0-слово.
    if (n2 + k2 > n1) return;                   // Остаток равен делимому.
    assert (p1 [n1] != 0 && n1 > 0);

//      Делаем делимое положительным (старшее слово может стать нулевым).

    if (signrem < 0) {
      cBigNumberNeg (p1, p1);                   // Смена знака делимого.
    }

//      Дополнительные нулевые слова в остатке будут удалены при
//      его нормализации. Они нужны для cBigNumberMSubMulM.

    *p1 = n1 + 2; p1 [n1 + 2] = p1 [n1 + 1] = 0;

//      Выбираем алгоритм для многословного или однословного делителя.

    if (n2 > 1)                                 // Многословный делитель.
    {
      CBNC nb2 = (CBNC)_ulzcntCBNL (p2p);       // Число старших 0-битов.

//      Сдвигаем старшее слово делителя влево и добавляем 1 для оценки
//      младших слов. p2p может стать нулевым.

      p2p = _ushldCBNL (pp2 [n2 - 1], p2p, nb2) + 1;

//      Вычисляем остаток.

      n2 = n1 - n2; assert (n2 >= k2);          // Сдвиг делителя (слова).
      unsigned CBNL p1l = p1 [n1 - 1];          // Старшее слово делимого,
      unsigned CBNL p1h = p1 [n1];              // затем вычисленный множитель
                                                // для делителя.
//      Предварительное деление.

      CBNC nb1 = (CBNC)_ulzcntCBNL (p1h);       // Число старших 0-битов
      if (nb1 < nb2) { unsigned CBNL pa;        // меньше в делимом.
        assert (nb2 > 0);
        p1l = _ushrdCBNL (p1l, p1h, BITS - nb2);// Сдвиг делимого вправо и
        p1h = _ushrCBNL (p1h, BITS - nb2);      // деление старших слов дает
                                                // множитель для делителя.
        if (p2p) p1h = _udivdCBNL (p1l, p1h, p2p, &pa);
        CPRG('\n'); CPRG((CBNL)n1); CPRG(' '); CPRG((CBNL)n2);
        CPRG(' '); CPRG((CBNL)nb1); CPRG(' '); CPRG((CBNL)nb2);
        CPRG(' '); CPRG((CBNL)p1h);
        cBigNumberMSubMulM (p1, pp2, p1h, n2);  // Уменьшение остатка.
        p1l = p1 [n1 - 1]; p1h = p1 [n1];       // Старшие слова остатка.
      }

//      Основной цикл деления сохраняет старшее слово частного максимум на
//      на бит длиннее старшего слова делителя, чтобы не было избыточных
//      вычитаний делителя. На каждой итерации цикла накапливается частное.

      for (;; p1l = p1 [n1 - 1], p1h = p1 [n1]) // Основной цикл деления для
      {                                         // старших слов частного.
        nb1 = (CBNC)_ulzcntCBNL (p1h);          // Число старших 0-битов.
        CPRG('\n'); CPRG((CBNL)n1); CPRG(' '); CPRG((CBNL)n2);
        CPRG(' '); CPRG((CBNL)nb1); CPRG(' '); CPRG((CBNL)nb2);
        if (nb1 < nb2 || p2p <= (               // Compare number of bits.
            p1h =_ushldCBNL (p1l, p1h, nb2))    // Сдвиг делимого как делителя.
            && p2p)
        { CPRG(" 1");                           // Если делитель не больше,
          (*pfNumberMSubM)(p1, pp2, n2);        // то вычитание делителя.
          continue;
        }                                       // Если делитель стал больше
        if (n2 == k2) break;                    // и деление не завершено, то
                                                // сдвиг второго слова и делим.
        if (p2p) { unsigned CBNL pa;            // Результат уже в p1h?
          p1l = _ushldCBNL ((n1 > 2 ? p1 [n1 - 2] : 0), p1l, nb2);
          p1h = _udivdCBNL (p1l, p1h, p2p, &pa);
        }                                       // Множитель для делителя.
        n2--; CPRG(' '); CPRG((CBNL)p1h);       // Уменьшегие сдвига делителя,
        cBigNumberMSubMulM (p1, pp2, p1h, n2);  // уменьшение остатка.

//      При оценке младших слов делителя можно получить ненулевое старшее
//      слово остатка, если nb2 = 0. В этом редком случае мы должны сделать
//      дополнительное вычитание делителя и приращение частного.

        if (p1 [n1--] != 0) { CPRG("+1");       // Если старшее слово не 0,
          (*pfNumberMSubM)(p1, pp2, n2);        // то вычитание делителя.
          assert (p1 [n1 + 1] == 0);            // Остаток укоротился на слово.
        }
      }                                         // Конец основного цикла.

//      Сравнение остатка и делителя, поскольку цикл может быть завершен
//      когда остаток равен делителю или немного больше.

      n2 = n1 - n2;                             // Восстановление n2 как числа
      assert (n1 == n2 + k2 && n2 > 0);         // слов в беззнаковом pp2.
      do continue; while ((p1h = p1 [n2 + k2]) == (p2p = pp2 [n2]) && --n2);
      if (p1h >= p2p) { CPRG("+1");             // Если остаток не меньше,
        (*pfNumberMSubM)(p1, pp2, k2);          // то вычитание делителя.
      }
    }
    else if (n1 - 1 > k2) // n2 == 1            // Однословный делитель,
    {                                           // многословное делимое.
      n2 = n1 - 1;                              // Сдвиг делителя (слова).
      do                                        // Основной цикл деления.
      {                                         // Старшее слово частного,
        unsigned CBNL p1h = p1 [n2 + 1];        // множитель для делителя
        CPRG('\n'); CPRG((CBNL)n2);
        if (p2p <= p1h) {                       // Если делитель не больше,
          p1h /= p2p;                           // то деление старшего слова
        } else { unsigned CBNL pa;              // иначе деление старших слов и
          p1h = _udivdCBNL (p1 [n2], p1h, p2p, &pa);
          n2--;                                 // уменьшение сдвига делителя.
        }
        CPRG(' '); CPRG((CBNL)p1h);
        cBigNumberMSubMulM (p1, pp2, p1h, n2);  // Уменьшение остатка.
      }
      while (n2 > k2);                          // Конец основного цикла.
    }
    else // n1 == k2 + 1 && n2 == 1             // Простое однословное деление.
    {
      p1 [n1] %= p2p;                           // Запоминание остатка.
    }

    // Нормализация остатка.

    while (p1 [n1] == 0 && n1 > 1) --n1;        // Исключение старших 0-слов.
    p1 [0] = n1 + (p1 [n1] < 0);                // Резервирование слова для знака.
    if (signrem < 0) cBigNumberNeg (p1, p1);    // Установка знака остатка.

#endif//_CBIGNUM_SUBMUL_DIV

    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.

#ifdef  _CBIGNUM_SMALL_DIV
    return;
  }

//      Оптимизированные алгоритмы для однословного или двухсловного
//      ненулевого делителя.

  unsigned CBNL p1h = p1 [n1];                  // Старшее слово делимого.

//      Алгоритмы для делимого, которое не длиннее делителя.

  if (n1 <= n2)                                 // Делимое не длиннее делителя.
  {
//      Если делимое короче делителя, то делить не надо,
//      кроме случая ненормализованного делителя.

CompareSize:
    if (n1 == n2)                               // Сравнение размера.

//      Выбираем алгоритм для двухсловного или однословного деления.

#if _CBIGNUM_SMALL_DIV > 1
    switch (n2)
#endif//_CBIGNUM_SMALL_DIV
    {
#if _CBIGNUM_SMALL_DIV > 1
    case 2:                                     // Двухсловное делимое,
    {                                           // двухсловный делитель.
      assert (n1 == 2 && n2 == 2);

      if ((CBNL)p2h == ((CBNL)p2l >> (BITS-1))) // Делитель не нормализован -
        goto LongerDividend;                    // выбираем большее делимое.

      unsigned CBNL p1l = p1 [1];               // Младшее слово делимого.

//     Обеспечиваем положительный знак операндов.

      if ((CBNL)p1h < 0) {
        p1h = ~p1h + ((p1l = -(CBNL)p1l) == 0); // Неотрицательное делимое.
        if ((CBNL)p1h < 0) goto LongerDividend; // Делимое -CBNL_MIN,0 длиннее,
      }                                         // продолжаем с нормализованным
      assert ((CBNL)p1h >= 0);                  // и неотрицательным.

      if ((CBNL)p2h < 0)
        p2h = ~p2h + ((p2l = -(CBNL)p2l) == 0); // Положительный делитель.
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && (p2h | p2l) > 0);

//      Определяем разницу в числе значащих бит.
//      Разница не больше BITS-1, т.к. p1h имеет старший бит 0.

      CBNC nb = (int)_ulzcntCBNL (p2h) - (int)_ulzcntCBNL (p1h);
      if (nb >= 0)                              // Делимое имеет не меньше
      {                                         // бит, чем делитель.
        assert ((unsigned CBNC)nb < BITS);      // Проверка границ сдвига.
        p2h = _ushldCBNL (p2l, p2h, nb);        // Выравнивание делителя.
        p2l = _ushlCBNL (p2l, nb);
        do                                      // Цикл по битам.
        {                                       // Если остаток не меньше,
          unsigned CBNL pnh, pnl;               // то вычитание делителя.
          _sbbCBNL (_subCBNL (p1l, p2l, &pnl), p1h, p2h, &pnh);
          if ((CBNL)pnh >= 0) p1h = pnh; p1l = (CBNL)pnh >= 0? pnl: p1l;
        }
        while ((p2l = _ushrd1CBNL (p2l, p2h),
                p2h >>= 1, --nb) >= 0);         // Конец цикла по битам.
      }

      assert ((CBNL)p1h >= 0);                  // Проверка неотрицательности.
      if (p1 [2] < 0)                           // Установка знака остатка.
        p1h = ~p1h + ((p1l = -(CBNL)p1l) == 0);
      p1 [0] = 1 + ((CBNL)p1h != ((CBNL)p1l >> (BITS-1)));
      p1 [1] = p1l; p1 [2] = p1h;               // Запоминание остатка.
      assert (cBigNumberIsFit (p1));            // Проверка нормализованности.
      break; /* switch */
    }

//      Однословное деление может быть аппаратным, если это разрешено.

    default: /* n1 == 1 */                      // Однословный делитель,
                                                // однословное делимое.
#endif//_CBIGNUM_SMALL_DIV
      assert (n1 == 1 && n2 == 1);

//     Обеспечиваем положительный знак операндов.

      if ((CBNL)p1h < 0) p1h = -(CBNL)p1h;      // Неотрицательное делимое.
      assert (p1h <= (unsigned CBNL)(CBNL_MIN));

      if ((CBNL)p2h < 0) p2h = -(CBNL)p2h;      // Положительный делитель.
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && p2h != 0);

#ifdef  _CBIGNUM_HARDWARE_DIV
      p1h %= p2h;                               // Остаток.
#else //_CBIGNUM_HARDWARE_DIV

//      Определяем разницу в числе значащих бит.
//      Разница не больше BITS-1, т.к. p2h не больше 0.

      CBNC nb = (int)_ulzcntCBNL (p2h) - (int)_ulzcntCBNL (p1h);
      if (nb >= 0)                              // Делимое имеет не меньше
      {                                         // бит, чем делитель.
        assert ((unsigned CBNC)nb < BITS);      // Проверка границ сдвига.
        p2h <<= nb;                             // Выравнивание делителя.
        do                                      // Цикл по битам.
        {
          CBNL pnh = p1h - p2h;                 // Если остаток не меньше,
          if (pnh >= 0) p1h = pnh;              // то вычитание делителя.
        }
        while ((p2h >>= 1, --nb) >= 0);         // Конец цикла по битам.
      }
#endif//_CBIGNUM_HARDWARE_DIV

      assert (p1h <= (unsigned CBNL)(CBNL_MIN));
      if (p1 [1] >= 0) p1 [1] = p1h;            // Запоминание остатка.
      else             p1 [1] = -(CBNL)p1h;     // Установка знака остатка.
    }
    else if ((CBNL)p2h == ((CBNL)p2l >> (BITS-1)) ||
             p2h == 0 && p2l == (((unsigned CBNL)1) << (BITS-1)))
    {                                           // Удаляем лишнее старшее слово
      p2h = p2l; --n2; goto CompareSize;        // у более длинного делителя
    }                                           // и сравниваем размеры снова.
  }

//      Алгоритмы для многословного делимого, которое длиннее делителя состоят
//      из двух частей. Первая часть сокращает делимое или остаток до размеров
//      делителя, а вторая заканчивает деление при одинаковых размерах.

  else /* n1 > n2 */                            // Делимое длиннее делителя.
  {
#if _CBIGNUM_SMALL_DIV > 1
LongerDividend:
#endif//_CBIGNUM_SMALL_DIV
    if ((CBNL)p1h < 0) {                        // Для отрицательного делимого
      p1 [0] = p1h;                             // сохраняем знак делимого и
      size_t n = 0;                             // берем абсолютное значение.
      do ++n; while ((p1 [n] = p1h = -p1 [n]) == 0); ++n;
      if (n <= n1) do p1 [n] = p1h = ~p1 [n]; while (++n <= n1);
      else if ((CBNL)p1h < 0) { p1h = 0; ++n1; }// Добавляем старшее слово к
    }                                           // -CBNL_MIN, нормализуя до
    assert ((CBNL)p1h >= 0);                    // неотрицательного делимого.

//      Сдвиг делимого влево до максимального значения со старшим битом 0.

    CBNC nb1 = (int)_ulzcntCBNL (p1h) - 1;      // Сдвиг делимого влево.
    assert ((unsigned CBNC)nb1 < BITS);         // Проверка границ сдвига.

//      Выбираем алгоритм для двухсловного или однословного делителя.

#if _CBIGNUM_SMALL_DIV > 1
    switch (n2)
#endif//_CBIGNUM_SMALL_DIV
    {
#if _CBIGNUM_SMALL_DIV > 1
    case 2:                                     // Многословное делимое,
    if ((CBNL)p2h != ((CBNL)p2l >> (BITS-1)))   // двухсловный делитель,
    {                                           // который нормализован.
      assert (n1 > 2);

      if ((CBNL)p2h < 0)
        p2h = ~p2h + ((p2l = -(CBNL)p2l) == 0);
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && (p2h | p2l) > 0);

//      Делитель сдвигается влево до максимального значения со старшим битом 0.
//      Исключением является делитель -CBNL_MIN,0 который остается как есть.

      CBNC nb2 = (int)_ulzcntCBNL (p2h) - 1;    // Сдвиг делителя влево.
      if (nb2 < 0) nb2 = 0;                     // Случай -CBNL_MIN,0.
      assert ((unsigned CBNC)nb2 < BITS);       // Проверка границ сдвига.
      p2h = _ushldCBNL (p2l, p2h, nb2);         // Сдвиг старшего слова.
      p2l = _ushlCBNL (p2l, nb2);               // Сдвиг младшего слова.
      assert (p2h >= (((unsigned CBNL)1) << (BITS-2)));

//      Делимое сдвигается влево до максимального значения со старшим битом 0.

      unsigned CBNL p1l = p1 [--n1];            // Предыдущее слово делимого.
      unsigned CBNL p1n = 0;                    // Следующее слово делимого.
      if (nb1 > 0)                              // Сдвиг делимого влево до
      {                                         // единственного старшего 0-бита.
        p1n = p1 [--n1];                        // Следующее слово делимого.
        p1h = _ushldCBNL (p1l, p1h, nb1);       // Сдвиг старшего слова делимого,
        p1l = _ushldCBNL (p1n, p1l, nb1);       // предыдущего слова делимого
        p1n = _ushlCBNL (p1n, nb1);             // и следующего за ним слова.
        nb1 -= BITS;
      }
      assert (p1h >= (((unsigned CBNL)1) << (BITS-2)));

//      Вычисление модуля (остатка).

      for (;;)                                  // Цикл по битам.
      {                                         // Если остаток не меньше,
        unsigned CBNL pnh, pnl;                 // то вычитание делителя.
        _sbbCBNL (_subCBNL (p1l, p2l, &pnl), p1h, p2h, &pnh);
        if ((CBNL)pnh >= 0) p1h = pnh; p1l = (CBNL)pnh >= 0? pnl: p1l;
        if (++nb1 > 0)                          // Биты закончились.
        {
          if (--n1 == 0) break;                 // Слова делимого закончились.
          p1n = p1 [n1]; nb1 -= BITS;           // Следующее слово делимого.
        }
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l = _ushld1CBNL (p1n, p1l);
        p1n += p1n;
      }                                         // Конец цикла по битам.

//      Двухсловное деление для остатка из двух слов.

      while ((p2l = _ushrd1CBNL (p2l, p2h),
              p2h >>= 1, --nb2) >= 0)           // Цикл по битам.
      {                                         // Если остаток не меньше,
        unsigned CBNL pnh, pnl;                 // то вычитание делителя.
        _sbbCBNL (_subCBNL (p1l, p2l, &pnl), p1h, p2h, &pnh);
        if ((CBNL)pnh >= 0) p1h = pnh; p1l = (CBNL)pnh >= 0? pnl: p1l;
      }                                         // Конец цикла по битам.

      assert ((CBNL)p1h >= 0);                  // Проверка неотрицательности.
      if (p1 [0] < 0) {                         // Установка знака остатка.
        p1h = ~p1h + ((p1l = -(CBNL)p1l) == 0);
      }
      p1 [0] = 1 + ((CBNL)p1h != ((CBNL)p1l >> (BITS-1)));
      p1 [1] = p1l; p1[2] = p1h;                // Запоминание остатка.
      assert (cBigNumberIsFit (p1));            // Проверка нормализованности.
      break; /* switch */
    }                                           // Удаление старшего слова
    p2h = p2l;                                  // ненормализованного делителя.

//      Алгоритм для однословного делителя может использовать аппаратное
//      деление, если оно разрешено.

    default: /* n2 == 1 */                      // Многословное делимое,
                                                // однословный делитель.
#endif//_CBIGNUM_SMALL_DIV
      assert (n1 > 1);
      unsigned CBNL p1l = 0;                    // Следующее слово делимого.

      if ((CBNL)p2h < 0) p2h = -(CBNL)p2h;      // Положительный делитель.
      assert (p2h <= (unsigned CBNL)(CBNL_MIN) && p2h > 0);

//      Сдвиг делителя влево до максимального значения со старшим битом 0.
//      Исключением является делитель -CBNL_MIN, который остается как есть.

      CBNC nb2 = (int)_ulzcntCBNL (p2h) - 1;    // Сдвиг делителя влево.
      if (nb2 < 0) nb2 = 0;                     // Случай -CBNL_MIN.
      assert ((unsigned CBNC)nb2 < BITS);       // Проверка границ сдвига.

//      Алгоритм реализован в двух модификациях в зависимости от
//      доступности аппаратного деления двойного слова на однословное.

#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)

//      Если делитель не короче делимого, сдвинутого влево на слово,
//      то проводится предварительное бинарное деление.

    if (n1 > 2 || nb2 >= nb1)
    {
#endif

      CBNC nb = nb2 - nb1;                      // Разница между сдвигами.
      if (nb < 0) nb += BITS;
      assert ((unsigned CBNC)nb < BITS);        // Проверка границ сдвига.

//      Делимое и делитель сдвигаются влево.

      if (nb1 > 0)                              // Сдвиг делимого влево до
      {                                         // единственного старшего 0-бита.
        p1l = p1 [--n1];                        // Следующее слово делимого.
        p1h = _ushldCBNL (p1l, p1h, nb1);       // Сдвиг старшего слова делимого
        p1l = _ushlCBNL (p1l, nb1);             // и следующего за ним слова.
        nb1 -= BITS;
      }
      assert (p1h >= (((unsigned CBNL)1) << (BITS-2)));
      p2h <<= nb2;                              // Сдвиг делителя.
      assert (p2h >= (((unsigned CBNL)1) << (BITS-2)));

//      Вычисление модуля (остатка).

      for (;;)                                  // Цикл по битам.
      {
        CBNL pnh = p1h - p2h;                   // Если остаток не меньше,
        if (pnh >= 0) p1h = pnh;                // то вычитание делителя.
        if (++nb1 > 0)                          // Биты закончились.
        {
#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
          p1l = p1 [--n1]; nb1 -= BITS;         // Следующее слово делимого.
#else
          if (--n1 == 0) break;                 // Слова делимого закончились.
          p1l = p1 [n1]; nb1 -= BITS;           // Следующее слово делимого.
#endif
        }
        p1h = _ushld1CBNL (p1l, p1h);           // Сдвиг остатка влево.
        p1l += p1l;
#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
        if (--nb < 0)                           // Можно делить аппаратно если
        {                                       // остаток короче делителя,
          if (n1 <= 1) break;                   // сдвинутого влево на слово.
          nb += BITS;
        }
#endif
      }                                         // Конец цикла по битам.
#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
      nb1 += BITS;
      p1l = _ushrdCBNL (p1l, p1h, nb1);         // Не сдвинутый остаток.
      p1h = _ushrCBNL (p1h, nb1);
      p2h = _ushrCBNL (p2h, nb2);               // Исходный делитель.
    }
    else p1l = p1 [1];                          // Младшее слово делимого.

//      Деление двухсловного числа на однословное.

      assert (p1h < p2h);                       // Проверка переполнения.
      p1 [1] = _umoddCBNL (p1l, p1h, p2h);      // Остаток.
      assert (p1 [1] >= 0);                     // Частное и остаток.
      if (p1 [0] < 0) p1 [1] = -p1 [1];         // Установка знака остатка.

#else //_CBIGNUM_HARDWARE_DIV && _CBNL_DIV

//      Однословное деление для остатка из одного слова.

#ifdef  _CBIGNUM_HARDWARE_DIV
      if (nb2 >= _CBNL_HARDDIV_BITS)            // Аппаратное деление при
      {                                         // наличии старших 0-бит.
        p2h >>= nb2;                            // Исходный делитель.
        p1h %= p2h;                             // Остаток.
      }
      else                                      // Бинарное деление.
#endif//_CBIGNUM_HARDWARE_DIV
      while ((p2h >>= 1, --nb2) >= 0)           // Цикл по битам.
      {
        CBNL pnh = p1h - p2h;                   // Если остаток не меньше,
        if (pnh >= 0) p1h = pnh;                // то вычитание делителя.
      }                                         // Конец цикла по битам.

      assert ((CBNL)p1h >= 0);                  // Проверка неотрицательности.
      if (p1 [0] >= 0) p1 [1] = p1h;            // Запоминание остатка.
      else             p1 [1] = -(CBNL)p1h;     // Установка знака остатка.

#endif//_CBIGNUM_HARDWARE_DIV && _CBNL_DIV

      p1 [0] = 1;                               // Число слов в остатке.
    }
  }
#endif//_CBIGNUM_SMALL_DIV
}

//================================================
//      Функции возведения в степень.
//================================================

//      Функция возведения в степень использует буфер основания,
//      как рабочий и требует, чтобы он был такого же размера, как
//      буфер результата. Оба буфера должны вмещать результат и еще
//      иметь два дополнительных слова для нужд операции умножения.
//      Отметим, что если в p2 более одного слова и p1 отлично
//      от -1,0,1, то размер буферов будет больше 512 MБайт.
//
//      Функция не требует нормализации операндов и всегда выдает
//      нормализованный результат.

void    cBigNumberPow (                         // Возведение p1 в степень p2.
                        EXPTR(CBNL) p1,         // Основание в рабочем буфере
                                                // размера *p + 3.
                const   CBPTR(CBNL) p2,         // Показатель.
                        EXPTR(CBNL) p           // Буфер для результата
                                                // размера *p + 3.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  p [0] = 1; p [1] = 1;                         // Начальная степень 1.

  if (CBPTRBASE(p2)[n2] < 0)                    // Отрицательный показатель?
  {
    cBigNumberFit (p1);                         // Нормализация.
    cBigNumberMModDiv (p, p1, p1);              // Целое частное 1/p1 или
    if (p1 [1] + (p2 [1] & 1) < 0) p1 [1] = 1;  // abs(1/p1) если p2 четное.
    p [1] = p1 [1];
    return;
  }
  assert (CBPTRBASE(p2)[n2] >= 0);              // Проверка неотрицательности.

  n2 = cBigNumberWords (p2);                    // Число значащих слов.
  if (n2 != 0)                                  // Степень может быть не 1?
  {
    p2++;                                       // Начало.
    unsigned CBNL num = *p2++; --n2;            // Текущее слово p2.
    unsigned CBNL mask = 1;                     // Маска для битов num.
    for (;;)                                    // Цикл по битам p2.
    {
      if (num & mask)                           // Если бит p2 установлен.
        cBigNumberMul (p1, p, p);               // Накопление степени.
      if (n2 == 0) {                            // Последнее слово p2.
        if ((num >>= 1) == 0) break;            // Биты p2 закончились.
      } else                                    // Не последнее слово p2.
        if ((mask <<= 1) == 0) {                // Биты num закончились.
          num = *p2++; mask = 1; --n2;          // Следующее слово p2.
        }
      cBigNumberMul (p1, p1, p1);               // Квадрат основания.
    }                                           // Конец цикла по битам p2.
  }
}

//      Функция возведения в степень по модулю использует буфер основания,
//      как рабочий. Необходимо, чтобы он был на два слова больше,
//      чем требуется для основания и не меньше буфера результата.
//      Буфер результата должен быть вдвое больше модуля, иметь два
//      дополнительных слово для нужд операции умножения и слово для размера.
//
//      Модуль должен быть ненулевым (если 0 и деление на 0 разрешено,
//      то результат будет 1).
//
//      Функция не требует нормализации операндов и всегда выдает
//      нормализованный результат.

void    cBigNumberPowMod (                      // Возведение p1 в степень p2.
                        EXPTR(CBNL) p1,         // Основание в рабочем буфере
                                                // размера max (*p, *p1 + 3).
                const   CBPTR(CBNL) p2,         // Показатель.
                const   CBPTR(CBNL) mod,        // Модуль.
                        EXPTR(CBNL) p           // Буфер для результата
                                                // размера *mod * 2 + 3.
        )                                       // p2, mod могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  assert (mod != p);                            // Проверка несовпадения.
  assert (mod != p1);                           // Проверка несовпадения.

  p [0] = 1; p [1] = 1;                         // Начальная степень 1.

  if (p1 [(size_t)(*p1)] < 0)                   // Отрицательное основание?
  {
    cBigNumberNeg (p1, p1);                     // Смена знака основания.
    cBigNumberPowMod (p1, p2, mod, p);          // Степень.
    if (p2 [1] & 1) cBigNumberNeg (p, p);       // Смена знака результата
    return;                                     // если степень нечетная.
  }
  assert (p1 [(size_t)(*p1)] >= 0);             // Проверка неотрицательности.
  cBigNumberFit (p1);                           // Нормализация.

  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  if (CBPTRBASE(p2)[n2] < 0)                    // Отрицательный показатель?
  {
    cBigNumberMModDiv (p, p1, p1);              // Целое частное 1/p1.
    p [1] = p1 [1]; cBigNumberMMod (p, mod);    // Модуль степени.
    return;
  }
  assert (CBPTRBASE(p2)[n2] >= 0);              // Проверка неотрицательности.
  p2++;                                         // Начало.

  size_t nmod = (size_t)(*CBPTRBASE(mod));      // Число слов.

//      Выделяем модуль, если он является однословным беззнаковым.

#ifdef  _CBIGNUM_SMALL_POWMOD
  unsigned CBNL pmh = 0;                        // Слово модуля или 0.
  if (nmod == 1)                                // Однословный модуль.
  {
    pmh = CBPTRBASE(mod) [1];                   // Модуль.
    if ((CBNL)pmh < 0) pmh = -(CBNL)pmh;        // Абсолютное значение модуля
  }                                             // в диапазоне 0..-CBNL_MIN.

//      Возведение в степень по модулю в общем или однословном случае.

  if (pmh <= 1)                                 // Общий случай.
#endif//_CBIGNUM_SMALL_POWMOD

//     Базовый алгоритм имеет версию с таблицей сдвигов, которая
//     используется для модулей длиннее _CBIGNUM_SMALL_DIV слов,
//     если не выбрано быстрое деление _CBIGNUM_SUBMUL_DIV.

#ifndef _CBIGNUM_SUBMUL_DIV
#ifdef  _CBIGNUM_SMALL_DIV
  if (nmod > _CBIGNUM_SMALL_DIV)                // Модуль с таблицей сдвигов.
#endif//_CBIGNUM_SMALL_DIV
  {
    cBigTemp cBigBuf3;                          // Выделение временного буфера.
    cBigBuf3.checkexpand (exmuladd (BITS, nmod, BITS * 3 + 1));
    EXPTR(CBNL) pmod = EXPTRTYPE(cBigBuf3);     // Буфер для модуля.

//      Копирование и нормализация ненулевого модуля с пропуском
//      младших 0-слов. Если модуль 0, то результат содержит 0 слов.

    size_t kmod = cBigNumberCopySkipLow0 (mod, pmod);
    nmod = (size_t)(*pmod);                     // Число слов.

//      Проверяем деление на 0.

    if (nmod == 0) { cBigNumberDiv0(); return; }

//      Обеспечиваем положительный знак модуля и
//      строим таблицу сдвигов для деления.

    if (pmod [nmod] < 0) nmod = cBigNumberNeg (pmod, pmod);
    cBigNumberTab (pmod);                       // Подготовка таблицы сдвигов.

//      Начальная степень. Частный случай - степень 0 и модуль 1,
//      для которого мы ставим корректный 0.

    p [1] = (nmod + kmod != 1 || pmod [nmod] != 1);

//      Готовим основание, чтобы поместилось в буфер после умножения.

    cBigNumberMModShlTab (p1, pmod, kmod);      // Модуль основания.

//      Возведение в степень по длинному модулю.

    if (n2)                                     // Есть слова в p2?
    {
      unsigned CBNL num = *p2++; --n2;          // Текущее слово p2.
      unsigned CBNL mask = 1;                   // Маска для битов num.
      for (;;)                                  // Цикл по битам p2.
      {
        if (num & mask)                         // Если бит p2 установлен.
        {
          cBigNumberMul (p1, p, p);             // Накопление степени.
          cBigNumberMModShlTab (p, pmod, kmod); // Модуль степени.
        }
        if (n2 == 0) {                          // Последнее слово p2.
          if ((num >>= 1) == 0) break;          // Биты p2 закончились.
        } else                                  // Не последнее слово p2.
          if ((mask <<= 1) == 0) {              // Биты num закончились.
            num = *p2++; mask = 1; --n2;        // Следующее слово p2.
          }
        cBigNumberMul (p1, p1, p1);             // Квадрат основания.
        cBigNumberMModShlTab (p1, pmod, kmod);  // Модуль квадрата основания.
      }                                         // Конец цикла по битам p2.
    }
  }
#ifdef  _CBIGNUM_SMALL_DIV
  else                                          // Модуль без таблицы сдвигов.
#endif//_CBIGNUM_SMALL_DIV
#endif//_CBIGNUM_SUBMUL_DIV
#if defined(_CBIGNUM_SUBMUL_DIV) || defined(_CBIGNUM_SMALL_DIV)
  {
//      Нормализация, проверка деления на 0 и коррекция результата
//      при возведении в степень 0 по модулю 1/-1.

#ifndef _CBIGNUM_SMALL_POWMOD
    unsigned CBNL
#endif
    pmh = CBPTRBASE(mod) [nmod];                // Старшее слово модуля.
#if defined(_CBIGNUM_SUBMUL_DIV) || _CBIGNUM_SMALL_DIV > 1
    for (;;)
    if (nmod > 1) {                             // Несколько слов?
      if ((CBNL)pmh != (mod [nmod - 1] >> (BITS-1))) break;
      pmh = mod [nmod - 1]; --nmod;             // Пропускаем лишнее слово.
    } else {
#endif
      if (pmh == 0) { cBigNumberDiv0(); return; }
      p [1] = ((unsigned CBNL)(pmh + 1) > 2);   // Модуль не 1 или -1.
#if defined(_CBIGNUM_SUBMUL_DIV) || _CBIGNUM_SMALL_DIV > 1
      break;
    }
#endif

//      Готовим основание, чтобы поместилось в буфер после умножения.

    cBigNumberMMod (p1, mod);                  // Модуль основания.

//      Возведение в степень по короткому модулю.

    if (n2)                                     // Есть слова в p2?
    {
      unsigned CBNL num = *p2++; --n2;          // Текущее слово p2.
      unsigned CBNL mask = 1;                   // Маска для битов num.
      for (;;)                                  // Цикл по битам p2.
      {
        if (num & mask)                         // Если бит p2 установлен.
        {
          cBigNumberMul (p1, p, p);             // Накопление степени.
          cBigNumberMMod (p, mod);              // Модуль степени.
        }
        if (n2 == 0) {                          // Последнее слово p2.
          if ((num >>= 1) == 0) break;          // Биты p2 закончились.
        } else                                  // Не последнее слово p2.
          if ((mask <<= 1) == 0) {              // Биты num закончились.
            num = *p2++; mask = 1; --n2;        // Следующее слово p2.
          }
        cBigNumberMul (p1, p1, p1);             // Квадрат основания.
        cBigNumberMMod (p1, mod);               // Модуль квадрата основания.
      }                                         // Конец цикла по битам p2.
    }
  }
#endif//_CBIGNUM_SUBMUL_DIV || _CBIGNUM_SMALL_DIV

#ifdef  _CBIGNUM_SMALL_POWMOD
  else// pmh > 1                                // Однословный модуль > 1.
  {
    assert (pmh > 1 && pmh <= (unsigned CBNL)(CBNL_MIN));

//      Готовим основание, чтобы число бит было не больше, чем в модуле.

    cBigNumberMMod (p1, mod);                   // Модуль основания.
    unsigned CBNL p1h = p1 [1];                 // Накапливаемая база.
    unsigned CBNL ph = 1; /* (pmh > 1) */       // Накапливаемая степень.

//      Возведение в степень по однословному модулю. Диапазон 2..-CBNL_MIN.

    if (n2)                                     // Есть слова в p2?
    {
      unsigned CBNL num = *p2++; --n2;          // Текущее слово p2.
      unsigned CBNL mask = 1;                   // Маска для битов num.

//     Простейший алгоритм использует умножение в двойное слово и деление
//     двойного слова. Он эффективен, если деление двойного слово реализовано
//     аппаратно, а иначе мы применяем более сложный метод.

#if defined(_CBIGNUM_HARDWARE_DIV) && defined(_CBNL_DIV)
      {
        for (;;)                                // Цикл по битам p2.
        {
          if (num & mask)                       // Если бит p2 установлен.
          {
            unsigned CBNL pp;                   // Буфер для старшего слова.
            ph = _umuldCBNL (p1h, ph, &pp);     // Накопление степени.
            ph = _umoddCBNL (ph, pp, pmh);      // Модуль степени.
          }
          if (n2 == 0) {                        // Последнее слово p2.
            if ((num >>= 1) == 0) break;        // Биты p2 закончились.
          } else                                // Не последнее слово p2.
            if ((mask <<= 1) == 0) {            // Биты num закончились.
              num = *p2++; mask = 1; --n2;      // Следующее слово p2.
            }
          {
            unsigned CBNL pp;                   // Буфер для старшего слова.
            p1h = _umuldCBNL (p1h, p1h, &pp);   // Квадрат основания.
            p1h = _umoddCBNL (p1h, pp, pmh);    // Модуль квадрата основания.
          }
        }                                       // Конец цикла по битам p2.
      }
#else //_CBIGNUM_HARDWARE_DIV && _CBNL_DIV

//      Для оптимизации операций вычисления модуля получаем нижнюю оценку
//      числа старших нулевых бит в результате. Для этой оценки берется
//      число старших нулевых бит в модуле, кроме специального случая
//      модуля -CBNL_MIN, для которого cLongBits выдает 1 вместо 0.
//      Диапазон оценки 1..BITS-2.

      unsigned CBNC nb = BITS - (unsigned CBNC)cLongBits (pmh);

//      Оптимизированное деление - аппаратное, бинарное или комбинированное.
//      Однословное аппаратное деление задействуется, если разрешено.

#ifdef  _CBIGNUM_HARDWARE_DIV
      if (nb >= BITS/2)                         // Модуль на пол-слова:
      {                                         // аппаратное деление.
        for (;;)                                // Цикл по битам p2.
        {
          if (num & mask)                       // Если бит p2 установлен.
          {
            ph *= p1h; ph %= pmh;               // Накопление степени.
          }
          if (n2 == 0) {                        // Последнее слово p2.
            if ((num >>= 1) == 0) break;        // Биты p2 закончились.
          } else                                // Не последнее слово p2.
            if ((mask <<= 1) == 0) {            // Биты num закончились.
              num = *p2++; mask = 1; --n2;      // Следующее слово p2.
            }
          p1h *= p1h; p1h %= pmh;               // Модуль квадрата основания.
        }                                       // Конец цикла по битам p2.
      }
      else if (nb >= _CBNL_HARDDIV_BITS)        // Однословный остаток путем
      {                                         // вычитания затем деление.
        unsigned CBNL pm = pmh;                 // Модуль для деления.
        pmh <<= (nb - 1);                       // Сдвинутый влево модуль
        assert (cLongBits (pmh) == BITS-1);     // для вычитания.
        nb = nb + nb - 1;                       // Исходный сдвиг произведения.
        for (;;)                                // Цикл по битам p2.
        {
          if (num & mask)                       // Если бит p2 установлен.
          {                                     // Накопление степени.
            unsigned CBNL pp;                   // Буфер для старшего слова.
            ph = _umuldCBNL (p1h, ph, &pp);     // Накопление степени.
            unsigned CBNL pl = ph << nb;        // Младшее сдвинутое слово.
            ph = _ushldCBNL (ph, pp, nb);       // Старшее сдвинутое слово.
            unsigned CBNC nbb = nb - BITS;      // Счетчик оставшихся сдвигов.
            do
            {                                   // Деление вычитанием:
              CBNL pnh = ph - pmh;              // если старшее слово не
              if (pnh >= 0) ph = pnh;           // меньше, то вычитание.
              ph = _ushld1CBNL (pl, ph);        // Сдвигаем остаток, пока сдвиг
              pl += pl;                         // не станет равным BITS.
            }
            while (++nbb);
            ph %= pm;                           // Однословное деление.
          }
          if (n2 == 0) {                        // Последнее слово p2.
            if ((num >>= 1) == 0) break;        // Биты p2 закончились.
          } else                                // Не последнее слово p2.
            if ((mask <<= 1) == 0) {            // Биты num закончились.
              num = *p2++; mask = 1; --n2;      // Следующее слово p2.
            }
          {
            unsigned CBNL pp;                   // Буфер для старшего слова.
            p1h = _umuldCBNL (p1h, p1h, &pp);   // Квадрат основания.
            unsigned CBNL p1l = p1h << nb;      // Младшее сдвинутое слово.
            p1h = _ushldCBNL (p1h, pp, nb);     // Старшее сдвинутое слово.
            unsigned CBNC nbb = nb - BITS;      // Счетчик оставшихся сдвигов.
            do
            {                                   // Деление вычитанием:
              CBNL pnh = p1h - pmh;             // если старшее слово не
              if (pnh >= 0) p1h = pnh;          // меньше, то вычитание.
              p1h = _ushld1CBNL (p1l, p1h);     // Сдвигаем остаток, пока сдвиг
              p1l += p1l;                       // не станет равным BITS.
            }
            while (++nbb);
            p1h %= pm;                          // Однословное деление.
          }
        }                                       // Конец цикла по битам p2.
      }
      else                                      // Деление путем вычитания.
#endif//_CBIGNUM_HARDWARE_DIV
      {
        for (;;)                                // Цикл по битам p2.
        {
          if (num & mask)                       // Если бит p2 установлен.
          {                                     // Накопление степени.
            unsigned CBNL pp;                   // Буфер для старшего слова.
            ph = _umuldCBNL (p1h, ph, &pp);     // Накопление степени.
            unsigned CBNL pl = ph << nb;        // Младшее сдвинутое слово.
            ph = _ushldCBNL (ph, pp, nb);       // Старшее сдвинутое слово.
            unsigned CBNC nbb = nb - BITS - 1;  // Счетчик оставшихся сдвигов.
            for (;;)
            {                                   // Деление вычитанием:
              CBNL pnh = ph - pmh;              // если старшее слово не
              if (pnh >= 0) ph = pnh;           // меньше, то вычитание.
              if (!++nbb) break;
              ph = _ushld1CBNL (pl, ph);        // Сдвигаем остаток, пока сдвиг
              pl += pl;                         // не станет равным BITS.
            }
          }
          if (n2 == 0) {                        // Последнее слово p2.
            if ((num >>= 1) == 0) break;        // Биты p2 закончились.
          } else                                // Не последнее слово p2.
            if ((mask <<= 1) == 0) {            // Биты num закончились.
              num = *p2++; mask = 1; --n2;      // Следующее слово p2.
            }
          {
            unsigned CBNL pp;                   // Буфер для старшего слова.
            p1h = _umuldCBNL (p1h, p1h, &pp);   // Квадрат основания.
            unsigned CBNL p1l = p1h << nb;      // Младшее сдвинутое слово.
            p1h = _ushldCBNL (p1h, pp, nb);     // Старшее сдвинутое слово.
            unsigned CBNC nbb = nb - BITS - 1;  // Счетчик оставшихся сдвигов.
            for (;;)
            {                                   // Деление вычитанием:
              CBNL pnh = p1h - pmh;             // если старшее слово не
              if (pnh >= 0) p1h = pnh;          // меньше, то вычитание.
              if (!++nbb) break;
              p1h = _ushld1CBNL (p1l, p1h);     // Сдвигаем остаток, пока сдвиг
              p1l += p1l;                       // не станет равным BITS.
            }
          }
        }                                       // Конец цикла по битам p2.
      }
#endif//_CBIGNUM_HARDWARE_DIV && _CBNL_DIV
    }
    assert (ph < pmh);                          // Проверка.
    p [1] = ph;                                 // Результат.
  }
#endif//_CBIGNUM_SMALL_POWMOD
}

//================================================
//      Функция целочисленного квадратного корня.
//================================================

//      Функция вычисляет целочисленный квадратный корень
//      и заносит остаток на место основания.
//      Если число бит > CBNL_MAX вызывается cBigNumberERange().
//
//      Основание должно быть нормализованным.
//      Функция всегда выдает нормализованный корень и остаток.

void    cBigNumberMRmSqrt (                     // Квадратный корень.
                        EXPTR(CBNL) p1,         // Основание, потом остаток.
                        EXPTR(CBNL) p           // Буфер размера *p1/2 + 2.
        )                                       // p1, p не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  assert (p1 [n1] >= 0);                        // Проверка неотрицательности.

  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf2.checkexpand (n1 + 1);                // +1 для отладочной проверки.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для вычитаемого.
  *pp2 = 0;                                     // Обнуление.
  cBigNumberFitTo (pp2, n1);                    // Заполнение.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

//      Алгоритм.

  CBNL nbit = (cBigNumberBits (p1) + 1) & ~1;
  if ((nbit -= 2) >= 0)
  {

//      Получение старшего бита вычитателя.

    {
      size_t nw = (size_t)(nbit / BITS);        // Слово.
      CBNL lw = (((CBNL)1) << (nbit % BITS));   // Маска.
      pp2 [nw + 1] += lw;                       // Установка бита.
      assert (pp2 [(size_t)(*pp2)] >= 0);       // Проверка неотрицательности.
      p1  [nw + 1] -= lw;                       // Вычитание без нормализации.
      assert (p1  [(size_t)(*p1)]  >= 0);       // Проверка неотрицательности.
    }

//      Обработка остальных битов вычитателя.
//      Вычитаемое и вычитатель пока не нормализованы, но будут
//      нормализованы при выполнении последующих операций.

    while ((nbit -= 2) >= 0)                    // Цикл по младшим битам.
    {
      size_t nw = (size_t)(nbit / BITS);        // Слово.
      CBNL lw = (((CBNL)1) << (nbit % BITS));   // Маска.
      pp2 [nw + 1] += lw;                       // Установка бита.
      if (cBigNumberComp (p1, pp2) < 0)         // Сравнение.
      {
        pp2 [nw] = (CBNL)(n1 - nw);             // Пропускаем младшие 0-слова.
        pp2 [nw + 1] -= lw;                     // Снятие бита.
        cBigNumberMDiv2D (pp2 + nw);            // Сдвиг вычитателя на бит.
      }
      else
      {
        pp2 [nw] = (CBNL)(n1 - nw);             // Пропускаем младшие 0-слова.
        cBigNumberMSubD (p1, pp2 + nw, nw);     // Коррекция остатка.
        assert (p1 [(size_t)(*p1)] >= 0);       // Проверка неотрицательности.
        assert (cBigNumberIsFit (p1));          // Проверка нормализованности.
        pp2 [nw + 1] -= lw;                     // Снятие бита.
        cBigNumberMDiv2D (pp2 + nw);            // Сдвиг вычитателя на бит.
        pp2 [nw + 1] += lw;                     // Установка бита.
      }
      n1 = (size_t)(pp2 [nw] + nw);             // Восстановление числа
      pp2 [nw] = 0;                             // после изменений для
      pp2 [0] = (CBNL)n1;                       // пропуска младших 0-слова.
      assert (pp2 [(size_t)(*pp2)] >= 0);       // Проверка неотрицательности.
      assert (cBigNumberIsFit (pp2));           // Проверка нормализованности.
    }
  }

  cBigNumberFit (pp2);                          // Нормализация корня.
  cBigNumberCopy (pp2, p);                      // Копирование корня.

//      Проверяем, что полученный корень дает наибольший квадрат,
//      не превосходящий по размеру заданное число.

  assert (cBigNumberComp ((cBigNumberMMul2M (pp2), pp2), p1) >= 0);
}

//================================================
//      Генератор случайных чисел.
//================================================

//      Генератор использует внешнюю функцию, возвращающую
//      случайное беззнаковое число с равномерным распределением
//      в диапазоне 0..ULONG_MAX.
//
//      В качестве результата формируется нормализованное случайное
//      значение с равномерным распределением для заданного числа бит.

void    cBigNumberRandom (                      // Случайное число.
                unsigned long (*pfnRand)(),     // Генератор случайных слов.
                unsigned CBNL lBits,            // Максимальное число бит.
                        EXPTR(CBNL) p           // Буфер размера lBits/BITS+1.
        )
{
  CBNL   l1 = lBits % BITS;                     // Число бит.
  size_t n1 = (size_t)(lBits / BITS + 1);       // Число слов.

  if (l1 != 0) l1 = cLongRandom (*pfnRand) &
                    (~(unsigned CBNL)0 >> (BITS-(size_t)l1));
  p [0] = (CBNL)n1;                             // Число слов.
  p [n1] = l1;                                  // Старшее слово.
  while (--n1 != 0) p [n1] = cLongRandom (*pfnRand);
                                                // Остальные слова.
  cBigNumberFit (p);                            // Нормализация.
  assert (p [(size_t)(*p)] >= 0);               // Проверка неотрицательности.
}

#ifdef  NCHECKPTR
#ifdef  __cplusplus
}
#endif//__cplusplus
#endif//NCHECKPTR

#endif//_CBIGNUMF_INL
