/* --------------------------------------------------------------
    Целые числа с неограниченной разрядной сеткой (версия 2.2).
    Макропараметры для базовых функций.

    http://www.imach.uran.ru/cbignum

    Copyright 1999-2025, Р.Н.Шакиров, ИМаш УрО PAH.
    All Rights Reserved.

    Код предоставляется на условиях лицензии "public domain",
    т.е. допускается свободное применение, модификация и
    распространение кода при условии сохранения копирайта
    и добавления сведений о всех внесенных изменениях.

    ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ"
    БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ. ВЫ
    ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ И РИСК. АВТОР
    НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ, УЩЕРБ,
    УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
    ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.
-------------------------------------------------------------- */
#ifndef _CBIGNUMF_H
#define _CBIGNUMF_H
#include "Cbnl.h"

//================================================
//      Применение ассемблерного пакета.
//================================================
//      _CBIGNUM_ASM            использовать код Cbignumf.cpp

#ifndef _CBIGNUMF_INL
#if 1
#define _CBIGNUM_ASM
#endif
#endif//_CBIGNUMF_INL

//================================================
//      Включение аппаратной оптимизации
//      для вычислительного ядра класса.
//================================================
//      _CBIGNUM_HARDWARE_CBR   развернутое сложение/вычитание/сдвиг с
//                              переносом/займом в ассемблерном пакете.
//      _CBIGNUM_HARDWARE_MUL   развернутое умножение с накоплением,
//                              реализованное в ассемблерном пакете или
//                              переносимое умножение в двойное слово.
//      _CBIGNUM_HARDWARE_DIV   деление одинарного и (при _CBNL_DIV)
//                              двойного слова.

#ifdef  _CBIGNUM_ASM

#ifdef  _CBNL_CBR
#if 1
#define _CBIGNUM_HARDWARE_CBR
#endif
#endif//_CBNL_CBR

#endif//_CBIGNUM_ASM

#ifdef  _CBNL_MUL
#if 1
#define _CBIGNUM_HARDWARE_MUL
#endif
#endif//_CBNL_MUL

#if 1
#define _CBIGNUM_HARDWARE_DIV
#endif

//================================================
//      Включение автоматической оптимизации.
//================================================
//      _CBIGNUM_KARATSUBA_MUL  использовать метод Карацубы, если
//                              оба числа имеют размер _CBNL_KARATSUBA_MIN
//                              и более слов.
//
//      _CBIGNUM_BLOCK_MUL      использовать блочное умножение, если
//                              оба числа имеют размер _CBNL_TAB_HIGH
//                              и более слов (блочный метод оптимален
//                              для кэша L1, теперь он заменяется
//                              более эффективным методом Карацубы,
//                              кроме случая, когда одно из чисел
//                              короче _CBNL_KARATSUBA_MIN слов).
//
//      _CBIGNUM_TERNARY_MUL    использовать ускоренный на 30% троичный
//                              метод умножения с таблицей сдвигов вместо
//                              более простого двоичного метода (теперь
//                              оба метода заменяются более эффективным
//                              аппаратным умножением, если оно разрешено).
//
//      _CBIGNUM_SHIFTTAB_MUL   строить таблицы сдвигов для ускорения
//                              умножения, если оба числа имеют размер
//                              _CBNL_TAB_MIN и более слов (теперь вместо
//                              этого применяется эффективное аппаратное
//                              умножение, если оно разрешено).
//
//      _CBIGNUM_SHIFTTAB_DIV   строить таблицу сдвигов для ускорения
//                              деления и модуля, если делитель как
//                              минимум на _CBNL_TAB_MIN слов короче
//                              делимого и имеет размер не более
//                              _CBNL_TAB_MAX слов (заменяется более
//                              эффективным методом _CBIGNUM_SUBMUL_DIV).
//
//      _CBIGNUM_SUBMUL_DIV     использовать умножение с накоплением
//                              для деления и модуля, если оно разрешено,
//                              кроме случая короткого делителя и модуля.
//
//      _CBIGNUM_SMALL_DIV      использовать специальные алгоритмы для
//                              короткого делителя и модуля, не длиннее
//                              указанного числа слов 1 или 2.
//
//      _CBIGNUM_SMALL_POWMOD   использовать специальный алгоритм для
//                              возведения в степень по короткому модулю,
//                              состоящему из одного слова.
//
//      _CBIGNUM_REVERSE_MOD    вычислять однословный модуль через обратное
//                              умножение после аппаратного деления.
//                              Выключено по умолчанию.
//
//      _CBIGNUM_REDUCE_JUMPS   использовать дополнительные операции
//                              для сокращения числа условных переходов.
//                              Зарезервировано для будущего применения.
//
//      _CBNL_SMALL_DIV         использовать специальный алгоритм для
//                              деления и модуля двойного слова вместо
//                              неограниченного, если нет _CBNL_DIV.

#if 1
#define _CBIGNUM_KARATSUBA_MUL
#endif

#if 1
#define _CBIGNUM_BLOCK_MUL
#endif

#if 1
#define _CBIGNUM_TERNARY_MUL
#endif

#if 1
#define _CBIGNUM_SHIFTTAB_MUL
#endif

#if 1
#define _CBIGNUM_SHIFTTAB_DIV
#endif

#ifdef  _CBIGNUM_HARDWARE_MUL
#if 1
#define _CBIGNUM_SUBMUL_DIV
#endif
#endif//_CBIGNUM_HARDWARE_MUL

#ifdef  _CBIGNUM_SUBMUL_DIV
#if 1
#define _CBIGNUM_SMALL_DIV 1
#endif
#else //_CBIGNUM_SUBMUL_DIV
#if 1
#define _CBIGNUM_SMALL_DIV 2
#endif
#endif//_CBIGNUM_SUBMUL_DIV

#if 1
#define _CBIGNUM_SMALL_POWMOD
#endif

#if 0
#define _CBIGNUM_REVERSE_MOD
#endif

#if 0
#define _CBIGNUM_REDUCE_JUMPS
#endif

#if 1
#define _CBNL_SMALL_DIV
#endif

//================================================
//      Настройка автоматической оптимизации.
//================================================
//      Следующие макросы выбирают алгоримты с аппаратным
//      умножением вместо построения таблицы сдвигов:
//      _CBIGNUM_HARDWARE_MUL   для умножения
//      _CBIGNUM_SUBMUL_DIV     для деления
//
//      _CBNL_TAB_MIN           минимальный размер множителя, при котором
//                              надо строить таблицу сдвигов множимого
//                              или
//                              минимальная разность размеров делимого и
//                              делителя, при котором надо строить
//                              таблицу сдвигов делителя.
//
//      _CBNL_TAB_OPT           оптимальный размер кусочка множимого
//                              при блочном умножении со сдвигом,
//                              когда неприменим метод Карацубы;
//                              лучше всего брать число 8n - 3.
//
//      _CBNL_TAB_HIGH          максимальный размер кусочка множимого
//                              при блочном умножении со сдвигом,
//                              когда неприменим метод Карацубы.
//
//      _CBNL_TAB_FULL          максимальный размер делителя, при котором
//                              мы используем полную таблицу сдвигов
//                              вместо половинной таблицы (эксперимент
//                              для 64-разрядного Visual C++).
//
//      _CBNL_TAB_MAX           максимальный размер делителя, при котором
//                              можно строить его таблицу сдвигов.
//
//      _CBNL_KARATSUBA_MIN     минимальный размер операндов для их
//                              умножения по методу Карацубы.
//
//      _CBNL_MUL_OPT           оптимальный размер кусочка множимого
//                              при аппаратном блочном умножении,
//                              когда неприменим метод Карацубы;
//                              лучше всего брать число 8n - 3.
//
//      _CBNL_MUL_HIGH          максимальный размер кусочка множимого
//                              при аппаратном блочном умножении,
//                              когда неприменим метод Карацубы.
//
//      Под размером понимается число слов CBNL в коде числа.
//
//      _CBNL_HARDDIV_BITS      минимальная разница в числе бит в делимом
//                              и делителе, когда аппаратное деление более
//                              эффективно, чем бинарный алгоритм.
//                              Влияет на деление многословного числа
//                              на однословное и степень по однословному
//                              модулю, если деление двухсловного числа
//                              на однословное не реализовано в
//                              ассемблерном пакте.

#define _CBNL_TAB_MIN   (3)
#define _CBNL_TAB_OPT   (((sizeof(size_t)<=2)? 120: 7680)/\
                         (sizeof (CBNL) * sizeof (CBNL)) - 3)
#define _CBNL_TAB_HIGH  (_CBNL_TAB_OPT + _CBNL_TAB_OPT / 2)
#if 0
#ifndef _CBIGNUM_SUBMUL_DIV
#ifdef  _MSC_VER
#ifdef  _WIN64
#define _CBNL_TAB_FULL  (64000/(sizeof (CBNL) * sizeof (CBNL)))
#endif//_WIN64
#endif//_MSC_VER
#endif//_CBIGNUM_SUBMUL_DIV
#endif
#define _CBNL_TAB_MAX   ((EXSIZE_T_MAX & (size_t)0x7FFFFFFFUL)/\
                         (1024 * sizeof (CBNL)))

#ifndef _CBIGNUM_HARDWARE_MUL
#define _CBNL_KARATSUBA_MIN     (100)
#else
#define _CBNL_KARATSUBA_MIN     (50)
#define _CBNL_MUL_OPT   (7680 / sizeof (CBNL) - 3)
#define _CBNL_MUL_HIGH  (_CBNL_MUL_OPT + _CBNL_MUL_OPT / 2)
#endif//_CBIGNUM_HARDWARE_MUL

#define _CBNL_HARDDIV_BITS 10

#endif//_CBIGNUMF_H
